// Package parser is generated by gogll. Do not edit.
//
//  Copyright 2019 Marius Ackerman
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
package parser

import (
	"bytes"
	"fmt"
	"os"
	"sort"

	"github.com/goccmack/gogll/lexer"
	"github.com/goccmack/gogll/parser/bsr"
	"github.com/goccmack/gogll/parser/slot"
	"github.com/goccmack/gogll/parser/symbols"
	"github.com/goccmack/gogll/token"
)

var (
	cI = 0

	R *descriptors
	U *descriptors

	popped   map[poppedNode]bool
	crf      map[clusterNode][]*crfNode
	crfNodes map[crfNode]*crfNode

	lex         *lexer.Lexer
	parseErrors []*Error
)

func initParser(l *lexer.Lexer) {
	lex = l
	cI = 0
	R, U = &descriptors{}, &descriptors{}
	popped = make(map[poppedNode]bool)
	crf = map[clusterNode][]*crfNode{
		{symbols.NT_GoGLL, 0}: {},
	}
	crfNodes = map[crfNode]*crfNode{}
	bsr.Init(symbols.NT_GoGLL, lex)
	parseErrors = nil
}

func Parse(l *lexer.Lexer) (error, []*Error) {
	initParser(l)
	var L slot.Label
	m, cU := len(l.Tokens)-1, 0
	ntAdd(symbols.NT_GoGLL, 0)
	// DumpDescriptors()
	for !R.empty() {
		L, cU, cI = R.remove()

		// fmt.Println()
		// fmt.Printf("L:%s, cI:%d, I[cI]:%s, cU:%d\n", L, cI, lex.Tokens[cI], cU)
		// DumpDescriptors()

		switch L {
		case slot.Rule0R0: // Rule : ∙LexRule

			call(slot.Rule0R1, cU, cI)
		case slot.Rule0R1: // Rule : LexRule ∙

			if follow(symbols.NT_Rule) {
				rtn(symbols.NT_Rule, cU, cI)
			} else {
				parseError(slot.Rule0R0, cI)
			}
		case slot.Rule1R0: // Rule : ∙SyntaxRule

			call(slot.Rule1R1, cU, cI)
		case slot.Rule1R1: // Rule : SyntaxRule ∙

			if follow(symbols.NT_Rule) {
				rtn(symbols.NT_Rule, cU, cI)
			} else {
				parseError(slot.Rule1R0, cI)
			}
		case slot.LexRule0R0: // LexRule : ∙TokID : RegExp ;

			call(slot.LexRule0R1, cU, cI)
		case slot.LexRule0R1: // LexRule : TokID ∙: RegExp ;

			if !testSelect(slot.LexRule0R1) {
				parseError(slot.LexRule0R1, cI)
				break
			}

			bsr.Add(slot.LexRule0R2, cU, cI, cI+1)
			cI++
			if !testSelect(slot.LexRule0R2) {
				parseError(slot.LexRule0R2, cI)
				break
			}

			call(slot.LexRule0R3, cU, cI)
		case slot.LexRule0R3: // LexRule : TokID : RegExp ∙;

			if !testSelect(slot.LexRule0R3) {
				parseError(slot.LexRule0R3, cI)
				break
			}

			bsr.Add(slot.LexRule0R4, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_LexRule) {
				rtn(symbols.NT_LexRule, cU, cI)
			} else {
				parseError(slot.LexRule0R3, cI)
			}
		case slot.LexGroup0R0: // LexGroup : ∙( LexAlternates )

			bsr.Add(slot.LexGroup0R1, cU, cI, cI+1)
			cI++
			if !testSelect(slot.LexGroup0R1) {
				parseError(slot.LexGroup0R1, cI)
				break
			}

			call(slot.LexGroup0R2, cU, cI)
		case slot.LexGroup0R2: // LexGroup : ( LexAlternates ∙)

			if !testSelect(slot.LexGroup0R2) {
				parseError(slot.LexGroup0R2, cI)
				break
			}

			bsr.Add(slot.LexGroup0R3, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_LexGroup) {
				rtn(symbols.NT_LexGroup, cU, cI)
			} else {
				parseError(slot.LexGroup0R2, cI)
			}
		case slot.LexOneOrMore0R0: // LexOneOrMore : ∙< LexAlternates >

			bsr.Add(slot.LexOneOrMore0R1, cU, cI, cI+1)
			cI++
			if !testSelect(slot.LexOneOrMore0R1) {
				parseError(slot.LexOneOrMore0R1, cI)
				break
			}

			call(slot.LexOneOrMore0R2, cU, cI)
		case slot.LexOneOrMore0R2: // LexOneOrMore : < LexAlternates ∙>

			if !testSelect(slot.LexOneOrMore0R2) {
				parseError(slot.LexOneOrMore0R2, cI)
				break
			}

			bsr.Add(slot.LexOneOrMore0R3, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_LexOneOrMore) {
				rtn(symbols.NT_LexOneOrMore, cU, cI)
			} else {
				parseError(slot.LexOneOrMore0R2, cI)
			}
		case slot.UnicodeClass0R0: // UnicodeClass : ∙letter

			bsr.Add(slot.UnicodeClass0R1, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_UnicodeClass) {
				rtn(symbols.NT_UnicodeClass, cU, cI)
			} else {
				parseError(slot.UnicodeClass0R0, cI)
			}
		case slot.UnicodeClass1R0: // UnicodeClass : ∙upcase

			bsr.Add(slot.UnicodeClass1R1, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_UnicodeClass) {
				rtn(symbols.NT_UnicodeClass, cU, cI)
			} else {
				parseError(slot.UnicodeClass1R0, cI)
			}
		case slot.UnicodeClass2R0: // UnicodeClass : ∙lowcase

			bsr.Add(slot.UnicodeClass2R1, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_UnicodeClass) {
				rtn(symbols.NT_UnicodeClass, cU, cI)
			} else {
				parseError(slot.UnicodeClass2R0, cI)
			}
		case slot.UnicodeClass3R0: // UnicodeClass : ∙number

			bsr.Add(slot.UnicodeClass3R1, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_UnicodeClass) {
				rtn(symbols.NT_UnicodeClass, cU, cI)
			} else {
				parseError(slot.UnicodeClass3R0, cI)
			}
		case slot.UnicodeClass4R0: // UnicodeClass : ∙space

			bsr.Add(slot.UnicodeClass4R1, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_UnicodeClass) {
				rtn(symbols.NT_UnicodeClass, cU, cI)
			} else {
				parseError(slot.UnicodeClass4R0, cI)
			}
		case slot.SyntaxSymbols0R0: // SyntaxSymbols : ∙SyntaxSymbol

			call(slot.SyntaxSymbols0R1, cU, cI)
		case slot.SyntaxSymbols0R1: // SyntaxSymbols : SyntaxSymbol ∙

			if follow(symbols.NT_SyntaxSymbols) {
				rtn(symbols.NT_SyntaxSymbols, cU, cI)
			} else {
				parseError(slot.SyntaxSymbols0R0, cI)
			}
		case slot.SyntaxSymbols1R0: // SyntaxSymbols : ∙SyntaxSymbol SyntaxSymbols

			call(slot.SyntaxSymbols1R1, cU, cI)
		case slot.SyntaxSymbols1R1: // SyntaxSymbols : SyntaxSymbol ∙SyntaxSymbols

			if !testSelect(slot.SyntaxSymbols1R1) {
				parseError(slot.SyntaxSymbols1R1, cI)
				break
			}

			call(slot.SyntaxSymbols1R2, cU, cI)
		case slot.SyntaxSymbols1R2: // SyntaxSymbols : SyntaxSymbol SyntaxSymbols ∙

			if follow(symbols.NT_SyntaxSymbols) {
				rtn(symbols.NT_SyntaxSymbols, cU, cI)
			} else {
				parseError(slot.SyntaxSymbols1R1, cI)
			}
		case slot.TokID0R0: // TokID : ∙tokid

			bsr.Add(slot.TokID0R1, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_TokID) {
				rtn(symbols.NT_TokID, cU, cI)
			} else {
				parseError(slot.TokID0R0, cI)
			}
		case slot.GoGLL0R0: // GoGLL : ∙Package Rules

			call(slot.GoGLL0R1, cU, cI)
		case slot.GoGLL0R1: // GoGLL : Package ∙Rules

			if !testSelect(slot.GoGLL0R1) {
				parseError(slot.GoGLL0R1, cI)
				break
			}

			call(slot.GoGLL0R2, cU, cI)
		case slot.GoGLL0R2: // GoGLL : Package Rules ∙

			if follow(symbols.NT_GoGLL) {
				rtn(symbols.NT_GoGLL, cU, cI)
			} else {
				parseError(slot.GoGLL0R1, cI)
			}
		case slot.LexBracket0R0: // LexBracket : ∙LexGroup

			call(slot.LexBracket0R1, cU, cI)
		case slot.LexBracket0R1: // LexBracket : LexGroup ∙

			if follow(symbols.NT_LexBracket) {
				rtn(symbols.NT_LexBracket, cU, cI)
			} else {
				parseError(slot.LexBracket0R0, cI)
			}
		case slot.LexBracket1R0: // LexBracket : ∙LexOptional

			call(slot.LexBracket1R1, cU, cI)
		case slot.LexBracket1R1: // LexBracket : LexOptional ∙

			if follow(symbols.NT_LexBracket) {
				rtn(symbols.NT_LexBracket, cU, cI)
			} else {
				parseError(slot.LexBracket1R0, cI)
			}
		case slot.LexBracket2R0: // LexBracket : ∙LexZeroOrMore

			call(slot.LexBracket2R1, cU, cI)
		case slot.LexBracket2R1: // LexBracket : LexZeroOrMore ∙

			if follow(symbols.NT_LexBracket) {
				rtn(symbols.NT_LexBracket, cU, cI)
			} else {
				parseError(slot.LexBracket2R0, cI)
			}
		case slot.LexBracket3R0: // LexBracket : ∙LexOneOrMore

			call(slot.LexBracket3R1, cU, cI)
		case slot.LexBracket3R1: // LexBracket : LexOneOrMore ∙

			if follow(symbols.NT_LexBracket) {
				rtn(symbols.NT_LexBracket, cU, cI)
			} else {
				parseError(slot.LexBracket3R0, cI)
			}
		case slot.LexOptional0R0: // LexOptional : ∙[ LexAlternates ]

			bsr.Add(slot.LexOptional0R1, cU, cI, cI+1)
			cI++
			if !testSelect(slot.LexOptional0R1) {
				parseError(slot.LexOptional0R1, cI)
				break
			}

			call(slot.LexOptional0R2, cU, cI)
		case slot.LexOptional0R2: // LexOptional : [ LexAlternates ∙]

			if !testSelect(slot.LexOptional0R2) {
				parseError(slot.LexOptional0R2, cI)
				break
			}

			bsr.Add(slot.LexOptional0R3, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_LexOptional) {
				rtn(symbols.NT_LexOptional, cU, cI)
			} else {
				parseError(slot.LexOptional0R2, cI)
			}
		case slot.LexZeroOrMore0R0: // LexZeroOrMore : ∙{ LexAlternates }

			bsr.Add(slot.LexZeroOrMore0R1, cU, cI, cI+1)
			cI++
			if !testSelect(slot.LexZeroOrMore0R1) {
				parseError(slot.LexZeroOrMore0R1, cI)
				break
			}

			call(slot.LexZeroOrMore0R2, cU, cI)
		case slot.LexZeroOrMore0R2: // LexZeroOrMore : { LexAlternates ∙}

			if !testSelect(slot.LexZeroOrMore0R2) {
				parseError(slot.LexZeroOrMore0R2, cI)
				break
			}

			bsr.Add(slot.LexZeroOrMore0R3, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_LexZeroOrMore) {
				rtn(symbols.NT_LexZeroOrMore, cU, cI)
			} else {
				parseError(slot.LexZeroOrMore0R2, cI)
			}
		case slot.LexAlternates0R0: // LexAlternates : ∙RegExp

			call(slot.LexAlternates0R1, cU, cI)
		case slot.LexAlternates0R1: // LexAlternates : RegExp ∙

			if follow(symbols.NT_LexAlternates) {
				rtn(symbols.NT_LexAlternates, cU, cI)
			} else {
				parseError(slot.LexAlternates0R0, cI)
			}
		case slot.LexAlternates1R0: // LexAlternates : ∙RegExp | LexAlternates

			call(slot.LexAlternates1R1, cU, cI)
		case slot.LexAlternates1R1: // LexAlternates : RegExp ∙| LexAlternates

			if !testSelect(slot.LexAlternates1R1) {
				parseError(slot.LexAlternates1R1, cI)
				break
			}

			bsr.Add(slot.LexAlternates1R2, cU, cI, cI+1)
			cI++
			if !testSelect(slot.LexAlternates1R2) {
				parseError(slot.LexAlternates1R2, cI)
				break
			}

			call(slot.LexAlternates1R3, cU, cI)
		case slot.LexAlternates1R3: // LexAlternates : RegExp | LexAlternates ∙

			if follow(symbols.NT_LexAlternates) {
				rtn(symbols.NT_LexAlternates, cU, cI)
			} else {
				parseError(slot.LexAlternates1R2, cI)
			}
		case slot.SyntaxRule0R0: // SyntaxRule : ∙NT : SyntaxAlternates ;

			call(slot.SyntaxRule0R1, cU, cI)
		case slot.SyntaxRule0R1: // SyntaxRule : NT ∙: SyntaxAlternates ;

			if !testSelect(slot.SyntaxRule0R1) {
				parseError(slot.SyntaxRule0R1, cI)
				break
			}

			bsr.Add(slot.SyntaxRule0R2, cU, cI, cI+1)
			cI++
			if !testSelect(slot.SyntaxRule0R2) {
				parseError(slot.SyntaxRule0R2, cI)
				break
			}

			call(slot.SyntaxRule0R3, cU, cI)
		case slot.SyntaxRule0R3: // SyntaxRule : NT : SyntaxAlternates ∙;

			if !testSelect(slot.SyntaxRule0R3) {
				parseError(slot.SyntaxRule0R3, cI)
				break
			}

			bsr.Add(slot.SyntaxRule0R4, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_SyntaxRule) {
				rtn(symbols.NT_SyntaxRule, cU, cI)
			} else {
				parseError(slot.SyntaxRule0R3, cI)
			}
		case slot.SyntaxSymbol0R0: // SyntaxSymbol : ∙NT

			call(slot.SyntaxSymbol0R1, cU, cI)
		case slot.SyntaxSymbol0R1: // SyntaxSymbol : NT ∙

			if follow(symbols.NT_SyntaxSymbol) {
				rtn(symbols.NT_SyntaxSymbol, cU, cI)
			} else {
				parseError(slot.SyntaxSymbol0R0, cI)
			}
		case slot.SyntaxSymbol1R0: // SyntaxSymbol : ∙TokID

			call(slot.SyntaxSymbol1R1, cU, cI)
		case slot.SyntaxSymbol1R1: // SyntaxSymbol : TokID ∙

			if follow(symbols.NT_SyntaxSymbol) {
				rtn(symbols.NT_SyntaxSymbol, cU, cI)
			} else {
				parseError(slot.SyntaxSymbol1R0, cI)
			}
		case slot.SyntaxSymbol2R0: // SyntaxSymbol : ∙string_lit

			bsr.Add(slot.SyntaxSymbol2R1, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_SyntaxSymbol) {
				rtn(symbols.NT_SyntaxSymbol, cU, cI)
			} else {
				parseError(slot.SyntaxSymbol2R0, cI)
			}
		case slot.Package0R0: // Package : ∙package string_lit

			bsr.Add(slot.Package0R1, cU, cI, cI+1)
			cI++
			if !testSelect(slot.Package0R1) {
				parseError(slot.Package0R1, cI)
				break
			}

			bsr.Add(slot.Package0R2, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_Package) {
				rtn(symbols.NT_Package, cU, cI)
			} else {
				parseError(slot.Package0R1, cI)
			}
		case slot.Rules0R0: // Rules : ∙Rule

			call(slot.Rules0R1, cU, cI)
		case slot.Rules0R1: // Rules : Rule ∙

			if follow(symbols.NT_Rules) {
				rtn(symbols.NT_Rules, cU, cI)
			} else {
				parseError(slot.Rules0R0, cI)
			}
		case slot.Rules1R0: // Rules : ∙Rule Rules

			call(slot.Rules1R1, cU, cI)
		case slot.Rules1R1: // Rules : Rule ∙Rules

			if !testSelect(slot.Rules1R1) {
				parseError(slot.Rules1R1, cI)
				break
			}

			call(slot.Rules1R2, cU, cI)
		case slot.Rules1R2: // Rules : Rule Rules ∙

			if follow(symbols.NT_Rules) {
				rtn(symbols.NT_Rules, cU, cI)
			} else {
				parseError(slot.Rules1R1, cI)
			}
		case slot.RegExp0R0: // RegExp : ∙LexSymbol

			call(slot.RegExp0R1, cU, cI)
		case slot.RegExp0R1: // RegExp : LexSymbol ∙

			if follow(symbols.NT_RegExp) {
				rtn(symbols.NT_RegExp, cU, cI)
			} else {
				parseError(slot.RegExp0R0, cI)
			}
		case slot.RegExp1R0: // RegExp : ∙LexSymbol RegExp

			call(slot.RegExp1R1, cU, cI)
		case slot.RegExp1R1: // RegExp : LexSymbol ∙RegExp

			if !testSelect(slot.RegExp1R1) {
				parseError(slot.RegExp1R1, cI)
				break
			}

			call(slot.RegExp1R2, cU, cI)
		case slot.RegExp1R2: // RegExp : LexSymbol RegExp ∙

			if follow(symbols.NT_RegExp) {
				rtn(symbols.NT_RegExp, cU, cI)
			} else {
				parseError(slot.RegExp1R1, cI)
			}
		case slot.LexSymbol0R0: // LexSymbol : ∙.

			bsr.Add(slot.LexSymbol0R1, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_LexSymbol) {
				rtn(symbols.NT_LexSymbol, cU, cI)
			} else {
				parseError(slot.LexSymbol0R0, cI)
			}
		case slot.LexSymbol1R0: // LexSymbol : ∙any string_lit

			bsr.Add(slot.LexSymbol1R1, cU, cI, cI+1)
			cI++
			if !testSelect(slot.LexSymbol1R1) {
				parseError(slot.LexSymbol1R1, cI)
				break
			}

			bsr.Add(slot.LexSymbol1R2, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_LexSymbol) {
				rtn(symbols.NT_LexSymbol, cU, cI)
			} else {
				parseError(slot.LexSymbol1R1, cI)
			}
		case slot.LexSymbol2R0: // LexSymbol : ∙char_lit

			bsr.Add(slot.LexSymbol2R1, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_LexSymbol) {
				rtn(symbols.NT_LexSymbol, cU, cI)
			} else {
				parseError(slot.LexSymbol2R0, cI)
			}
		case slot.LexSymbol3R0: // LexSymbol : ∙LexBracket

			call(slot.LexSymbol3R1, cU, cI)
		case slot.LexSymbol3R1: // LexSymbol : LexBracket ∙

			if follow(symbols.NT_LexSymbol) {
				rtn(symbols.NT_LexSymbol, cU, cI)
			} else {
				parseError(slot.LexSymbol3R0, cI)
			}
		case slot.LexSymbol4R0: // LexSymbol : ∙not string_lit

			bsr.Add(slot.LexSymbol4R1, cU, cI, cI+1)
			cI++
			if !testSelect(slot.LexSymbol4R1) {
				parseError(slot.LexSymbol4R1, cI)
				break
			}

			bsr.Add(slot.LexSymbol4R2, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_LexSymbol) {
				rtn(symbols.NT_LexSymbol, cU, cI)
			} else {
				parseError(slot.LexSymbol4R1, cI)
			}
		case slot.LexSymbol5R0: // LexSymbol : ∙UnicodeClass

			call(slot.LexSymbol5R1, cU, cI)
		case slot.LexSymbol5R1: // LexSymbol : UnicodeClass ∙

			if follow(symbols.NT_LexSymbol) {
				rtn(symbols.NT_LexSymbol, cU, cI)
			} else {
				parseError(slot.LexSymbol5R0, cI)
			}
		case slot.SyntaxAlternates0R0: // SyntaxAlternates : ∙SyntaxAlternate

			call(slot.SyntaxAlternates0R1, cU, cI)
		case slot.SyntaxAlternates0R1: // SyntaxAlternates : SyntaxAlternate ∙

			if follow(symbols.NT_SyntaxAlternates) {
				rtn(symbols.NT_SyntaxAlternates, cU, cI)
			} else {
				parseError(slot.SyntaxAlternates0R0, cI)
			}
		case slot.SyntaxAlternates1R0: // SyntaxAlternates : ∙SyntaxAlternate | SyntaxAlternates

			call(slot.SyntaxAlternates1R1, cU, cI)
		case slot.SyntaxAlternates1R1: // SyntaxAlternates : SyntaxAlternate ∙| SyntaxAlternates

			if !testSelect(slot.SyntaxAlternates1R1) {
				parseError(slot.SyntaxAlternates1R1, cI)
				break
			}

			bsr.Add(slot.SyntaxAlternates1R2, cU, cI, cI+1)
			cI++
			if !testSelect(slot.SyntaxAlternates1R2) {
				parseError(slot.SyntaxAlternates1R2, cI)
				break
			}

			call(slot.SyntaxAlternates1R3, cU, cI)
		case slot.SyntaxAlternates1R3: // SyntaxAlternates : SyntaxAlternate | SyntaxAlternates ∙

			if follow(symbols.NT_SyntaxAlternates) {
				rtn(symbols.NT_SyntaxAlternates, cU, cI)
			} else {
				parseError(slot.SyntaxAlternates1R2, cI)
			}
		case slot.SyntaxAlternate0R0: // SyntaxAlternate : ∙SyntaxSymbols

			call(slot.SyntaxAlternate0R1, cU, cI)
		case slot.SyntaxAlternate0R1: // SyntaxAlternate : SyntaxSymbols ∙

			if follow(symbols.NT_SyntaxAlternate) {
				rtn(symbols.NT_SyntaxAlternate, cU, cI)
			} else {
				parseError(slot.SyntaxAlternate0R0, cI)
			}
		case slot.SyntaxAlternate1R0: // SyntaxAlternate : ∙empty

			bsr.Add(slot.SyntaxAlternate1R1, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_SyntaxAlternate) {
				rtn(symbols.NT_SyntaxAlternate, cU, cI)
			} else {
				parseError(slot.SyntaxAlternate1R0, cI)
			}
		case slot.NT0R0: // NT : ∙nt

			bsr.Add(slot.NT0R1, cU, cI, cI+1)
			cI++
			if follow(symbols.NT_NT) {
				rtn(symbols.NT_NT, cU, cI)
			} else {
				parseError(slot.NT0R0, cI)
			}

		default:
			panic("This must not happen")
		}
	}
	if !bsr.Contain(symbols.NT_GoGLL, 0, m) {
		sortParseErrors()
		err := fmt.Errorf("Error: Parse Failed right extent=%d, m=%d",
			bsr.GetRightExtent(), len(l.Tokens))
		return err, parseErrors
	}
	return nil, nil
}

func ntAdd(nt symbols.NT, j int) {
	// fmt.Printf("ntAdd(%s, %d)\n", nt, j)
	failed := true
	for _, l := range slot.GetAlternates(nt) {
		if testSelect(l) {
			dscAdd(l, j, j)
			failed = false
		}
	}
	if failed {
		for _, l := range slot.GetAlternates(nt) {
			parseError(l, j)
		}
	}
}

/*** Call Return Forest ***/

type poppedNode struct {
	X    symbols.NT
	k, j int
}

type clusterNode struct {
	X symbols.NT
	k int
}

type crfNode struct {
	L slot.Label
	i int
}

/*
suppose that L is Y ::=αX ·β
if there is no CRF node labelled (L,i)
	create one let u be the CRF node labelled (L,i)
if there is no CRF node labelled (X, j) {
	create a CRF node v labelled (X, j)
	create an edge from v to u
	ntAdd(X, j)
} else {
	let v be the CRF node labelled (X, j)
	if there is not an edge from v to u {
		create an edge from v to u
		for all ((X, j,h)∈P) {
			dscAdd(L, i, h);
			bsrAdd(L, i, j, h)
		}
	}
}
*/
func call(L slot.Label, i, j int) {
	// fmt.Printf("call(%s,%d,%d)\n", L,i,j)
	u, exist := crfNodes[crfNode{L, i}]
	// fmt.Printf("  u exist=%t\n", exist)
	if !exist {
		u = &crfNode{L, i}
		crfNodes[*u] = u
	}
	X := L.Symbols()[L.Pos()-1].(symbols.NT)
	ndV := clusterNode{X, j}
	v, exist := crf[ndV]
	if !exist {
		// fmt.Println("  v !exist")
		crf[ndV] = []*crfNode{u}
		ntAdd(X, j)
	} else {
		// fmt.Println("  v exist")
		if !existEdge(v, u) {
			// fmt.Printf("  !existEdge(%v)\n", u)
			crf[ndV] = append(v, u)
			// fmt.Printf("|popped|=%d\n", len(popped))
			for pnd, _ := range popped {
				if pnd.X == X && pnd.k == j {
					dscAdd(L, i, pnd.j)
					bsr.Add(L, i, j, pnd.j)
				}
			}
		}
	}
}

func existEdge(nds []*crfNode, nd *crfNode) bool {
	for _, nd1 := range nds {
		if nd1 == nd {
			return true
		}
	}
	return false
}

func rtn(X symbols.NT, k, j int) {
	// fmt.Printf("rtn(%s,%d,%d)\n", X,k,j)
	p := poppedNode{X, k, j}
	if _, exist := popped[p]; !exist {
		popped[p] = true
		for _, nd := range crf[clusterNode{X, k}] {
			dscAdd(nd.L, nd.i, j)
			bsr.Add(nd.L, nd.i, k, j)
		}
	}
}

func CRFString() string {
	buf := new(bytes.Buffer)
	buf.WriteString("CRF: {")
	for cn, nds := range crf {
		for _, nd := range nds {
			fmt.Fprintf(buf, "%s->%s, ", cn, nd)
		}
	}
	buf.WriteString("}")
	return buf.String()
}

func (cn clusterNode) String() string {
	return fmt.Sprintf("(%s,%d)", cn.X, cn.k)
}

func (n crfNode) String() string {
	return fmt.Sprintf("(%s,%d)", n.L.String(), n.i)
}

func PoppedString() string {
	buf := new(bytes.Buffer)
	buf.WriteString("Popped: {")
	for p, _ := range popped {
		fmt.Fprintf(buf, "(%s,%d,%d) ", p.X, p.k, p.j)
	}
	buf.WriteString("}")
	return buf.String()
}

/*** descriptors ***/

type descriptors struct {
	set []*descriptor
}

func (ds *descriptors) contain(d *descriptor) bool {
	for _, d1 := range ds.set {
		if d1 == d {
			return true
		}
	}
	return false
}

func (ds *descriptors) empty() bool {
	return len(ds.set) == 0
}

func (ds *descriptors) String() string {
	buf := new(bytes.Buffer)
	buf.WriteString("{")
	for i, d := range ds.set {
		if i > 0 {
			buf.WriteString("; ")
		}
		fmt.Fprintf(buf, "%s", d)
	}
	buf.WriteString("}")
	return buf.String()
}

type descriptor struct {
	L slot.Label
	k int
	i int
}

func (d *descriptor) String() string {
	return fmt.Sprintf("%s,%d,%d", d.L, d.k, d.i)
}

func dscAdd(L slot.Label, k, i int) {
	// fmt.Printf("dscAdd(%s,%d,%d)\n", L, k, i)
	d := &descriptor{L, k, i}
	if !U.contain(d) {
		R.set = append(R.set, d)
		U.set = append(U.set, d)
	}
}

func (ds *descriptors) remove() (L slot.Label, k, i int) {
	d := ds.set[len(ds.set)-1]
	ds.set = ds.set[:len(ds.set)-1]
	// fmt.Printf("remove: %s,%d,%d\n", d.L, d.k, d.i)
	return d.L, d.k, d.i
}

func DumpDescriptors() {
	DumpR()
	DumpU()
}

func DumpR() {
	fmt.Println("R:")
	for _, d := range R.set {
		fmt.Printf(" %s\n", d)
	}
}

func DumpU() {
	fmt.Println("U:")
	for _, d := range U.set {
		fmt.Printf(" %s\n", d)
	}
}

/*** TestSelect ***/

func follow(nt symbols.NT) bool {
	_, exist := followSets[nt][lex.Tokens[cI].Type]
	return exist
}

func testSelect(l slot.Label) bool {
	_, exist := first[l][lex.Tokens[cI].Type]
	// fmt.Printf("testSelect(%s) = %t\n", l, exist)
	return exist
}

var first = []map[token.Type]string{
	// GoGLL : ∙Package Rules
	map[token.Type]string{
		token.Type17: "package",
	},
	// GoGLL : Package ∙Rules
	map[token.Type]string{
		token.Type15: "nt",
		token.Type20: "tokid",
	},
	// GoGLL : Package Rules ∙
	map[token.Type]string{
		token.EOF: "EOF",
	},
	// LexAlternates : ∙RegExp
	map[token.Type]string{
		token.Type0:  "(",
		token.Type2:  ".",
		token.Type5:  "<",
		token.Type7:  "[",
		token.Type9:  "any",
		token.Type10: "char_lit",
		token.Type12: "letter",
		token.Type13: "lowcase",
		token.Type14: "not",
		token.Type16: "number",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type22: "{",
	},
	// LexAlternates : RegExp ∙
	map[token.Type]string{
		token.Type1:  ")",
		token.Type8:  "]",
		token.Type24: "}",
		token.Type6:  ">",
	},
	// LexAlternates : ∙RegExp | LexAlternates
	map[token.Type]string{
		token.Type0:  "(",
		token.Type2:  ".",
		token.Type5:  "<",
		token.Type7:  "[",
		token.Type9:  "any",
		token.Type10: "char_lit",
		token.Type12: "letter",
		token.Type13: "lowcase",
		token.Type14: "not",
		token.Type16: "number",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type22: "{",
	},
	// LexAlternates : RegExp ∙| LexAlternates
	map[token.Type]string{
		token.Type23: "|",
	},
	// LexAlternates : RegExp | ∙LexAlternates
	map[token.Type]string{
		token.Type0:  "(",
		token.Type2:  ".",
		token.Type5:  "<",
		token.Type7:  "[",
		token.Type9:  "any",
		token.Type10: "char_lit",
		token.Type12: "letter",
		token.Type13: "lowcase",
		token.Type14: "not",
		token.Type16: "number",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type22: "{",
	},
	// LexAlternates : RegExp | LexAlternates ∙
	map[token.Type]string{
		token.Type6:  ">",
		token.Type1:  ")",
		token.Type8:  "]",
		token.Type24: "}",
	},
	// LexBracket : ∙LexGroup
	map[token.Type]string{
		token.Type0: "(",
	},
	// LexBracket : LexGroup ∙
	map[token.Type]string{
		token.Type8:  "]",
		token.Type10: "char_lit",
		token.Type14: "not",
		token.Type24: "}",
		token.Type13: "lowcase",
		token.Type7:  "[",
		token.Type12: "letter",
		token.Type1:  ")",
		token.Type2:  ".",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type6:  ">",
		token.Type4:  ";",
		token.Type22: "{",
		token.Type0:  "(",
		token.Type9:  "any",
		token.Type23: "|",
		token.Type16: "number",
		token.Type5:  "<",
	},
	// LexBracket : ∙LexOptional
	map[token.Type]string{
		token.Type7: "[",
	},
	// LexBracket : LexOptional ∙
	map[token.Type]string{
		token.Type6:  ">",
		token.Type2:  ".",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type16: "number",
		token.Type5:  "<",
		token.Type4:  ";",
		token.Type22: "{",
		token.Type0:  "(",
		token.Type9:  "any",
		token.Type23: "|",
		token.Type13: "lowcase",
		token.Type8:  "]",
		token.Type10: "char_lit",
		token.Type14: "not",
		token.Type24: "}",
		token.Type7:  "[",
		token.Type12: "letter",
		token.Type1:  ")",
	},
	// LexBracket : ∙LexZeroOrMore
	map[token.Type]string{
		token.Type22: "{",
	},
	// LexBracket : LexZeroOrMore ∙
	map[token.Type]string{
		token.Type24: "}",
		token.Type13: "lowcase",
		token.Type8:  "]",
		token.Type10: "char_lit",
		token.Type14: "not",
		token.Type7:  "[",
		token.Type12: "letter",
		token.Type1:  ")",
		token.Type21: "upcase",
		token.Type6:  ">",
		token.Type2:  ".",
		token.Type18: "space",
		token.Type23: "|",
		token.Type16: "number",
		token.Type5:  "<",
		token.Type4:  ";",
		token.Type22: "{",
		token.Type0:  "(",
		token.Type9:  "any",
	},
	// LexBracket : ∙LexOneOrMore
	map[token.Type]string{
		token.Type5: "<",
	},
	// LexBracket : LexOneOrMore ∙
	map[token.Type]string{
		token.Type8:  "]",
		token.Type10: "char_lit",
		token.Type14: "not",
		token.Type24: "}",
		token.Type13: "lowcase",
		token.Type7:  "[",
		token.Type12: "letter",
		token.Type1:  ")",
		token.Type2:  ".",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type6:  ">",
		token.Type4:  ";",
		token.Type22: "{",
		token.Type0:  "(",
		token.Type9:  "any",
		token.Type23: "|",
		token.Type16: "number",
		token.Type5:  "<",
	},
	// LexGroup : ∙( LexAlternates )
	map[token.Type]string{
		token.Type0: "(",
	},
	// LexGroup : ( ∙LexAlternates )
	map[token.Type]string{
		token.Type0:  "(",
		token.Type2:  ".",
		token.Type5:  "<",
		token.Type7:  "[",
		token.Type9:  "any",
		token.Type10: "char_lit",
		token.Type12: "letter",
		token.Type13: "lowcase",
		token.Type14: "not",
		token.Type16: "number",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type22: "{",
	},
	// LexGroup : ( LexAlternates ∙)
	map[token.Type]string{
		token.Type1: ")",
	},
	// LexGroup : ( LexAlternates ) ∙
	map[token.Type]string{
		token.Type8:  "]",
		token.Type10: "char_lit",
		token.Type1:  ")",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type22: "{",
		token.Type0:  "(",
		token.Type14: "not",
		token.Type7:  "[",
		token.Type12: "letter",
		token.Type2:  ".",
		token.Type16: "number",
		token.Type5:  "<",
		token.Type4:  ";",
		token.Type24: "}",
		token.Type13: "lowcase",
		token.Type6:  ">",
		token.Type9:  "any",
		token.Type23: "|",
	},
	// LexOneOrMore : ∙< LexAlternates >
	map[token.Type]string{
		token.Type5: "<",
	},
	// LexOneOrMore : < ∙LexAlternates >
	map[token.Type]string{
		token.Type0:  "(",
		token.Type2:  ".",
		token.Type5:  "<",
		token.Type7:  "[",
		token.Type9:  "any",
		token.Type10: "char_lit",
		token.Type12: "letter",
		token.Type13: "lowcase",
		token.Type14: "not",
		token.Type16: "number",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type22: "{",
	},
	// LexOneOrMore : < LexAlternates ∙>
	map[token.Type]string{
		token.Type6: ">",
	},
	// LexOneOrMore : < LexAlternates > ∙
	map[token.Type]string{
		token.Type5:  "<",
		token.Type22: "{",
		token.Type7:  "[",
		token.Type4:  ";",
		token.Type9:  "any",
		token.Type8:  "]",
		token.Type10: "char_lit",
		token.Type12: "letter",
		token.Type18: "space",
		token.Type16: "number",
		token.Type6:  ">",
		token.Type2:  ".",
		token.Type21: "upcase",
		token.Type0:  "(",
		token.Type23: "|",
		token.Type13: "lowcase",
		token.Type14: "not",
		token.Type24: "}",
		token.Type1:  ")",
	},
	// LexOptional : ∙[ LexAlternates ]
	map[token.Type]string{
		token.Type7: "[",
	},
	// LexOptional : [ ∙LexAlternates ]
	map[token.Type]string{
		token.Type0:  "(",
		token.Type2:  ".",
		token.Type5:  "<",
		token.Type7:  "[",
		token.Type9:  "any",
		token.Type10: "char_lit",
		token.Type12: "letter",
		token.Type13: "lowcase",
		token.Type14: "not",
		token.Type16: "number",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type22: "{",
	},
	// LexOptional : [ LexAlternates ∙]
	map[token.Type]string{
		token.Type8: "]",
	},
	// LexOptional : [ LexAlternates ] ∙
	map[token.Type]string{
		token.Type8:  "]",
		token.Type10: "char_lit",
		token.Type12: "letter",
		token.Type21: "upcase",
		token.Type6:  ">",
		token.Type22: "{",
		token.Type0:  "(",
		token.Type24: "}",
		token.Type2:  ".",
		token.Type23: "|",
		token.Type5:  "<",
		token.Type18: "space",
		token.Type4:  ";",
		token.Type13: "lowcase",
		token.Type14: "not",
		token.Type7:  "[",
		token.Type1:  ")",
		token.Type16: "number",
		token.Type9:  "any",
	},
	// LexRule : ∙TokID : RegExp ;
	map[token.Type]string{
		token.Type20: "tokid",
	},
	// LexRule : TokID ∙: RegExp ;
	map[token.Type]string{
		token.Type3: ":",
	},
	// LexRule : TokID : ∙RegExp ;
	map[token.Type]string{
		token.Type0:  "(",
		token.Type2:  ".",
		token.Type5:  "<",
		token.Type7:  "[",
		token.Type9:  "any",
		token.Type10: "char_lit",
		token.Type12: "letter",
		token.Type13: "lowcase",
		token.Type14: "not",
		token.Type16: "number",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type22: "{",
	},
	// LexRule : TokID : RegExp ∙;
	map[token.Type]string{
		token.Type4: ";",
	},
	// LexRule : TokID : RegExp ; ∙
	map[token.Type]string{
		token.Type15: "nt",
		token.EOF:    "EOF",
		token.Type20: "tokid",
	},
	// LexSymbol : ∙.
	map[token.Type]string{
		token.Type2: ".",
	},
	// LexSymbol : . ∙
	map[token.Type]string{
		token.Type24: "}",
		token.Type6:  ">",
		token.Type5:  "<",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type4:  ";",
		token.Type13: "lowcase",
		token.Type7:  "[",
		token.Type12: "letter",
		token.Type1:  ")",
		token.Type22: "{",
		token.Type10: "char_lit",
		token.Type8:  "]",
		token.Type16: "number",
		token.Type14: "not",
		token.Type0:  "(",
		token.Type2:  ".",
		token.Type9:  "any",
		token.Type23: "|",
	},
	// LexSymbol : ∙any string_lit
	map[token.Type]string{
		token.Type9: "any",
	},
	// LexSymbol : any ∙string_lit
	map[token.Type]string{
		token.Type19: "string_lit",
	},
	// LexSymbol : any string_lit ∙
	map[token.Type]string{
		token.Type8:  "]",
		token.Type22: "{",
		token.Type10: "char_lit",
		token.Type2:  ".",
		token.Type9:  "any",
		token.Type23: "|",
		token.Type16: "number",
		token.Type14: "not",
		token.Type0:  "(",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type24: "}",
		token.Type6:  ">",
		token.Type5:  "<",
		token.Type12: "letter",
		token.Type1:  ")",
		token.Type4:  ";",
		token.Type13: "lowcase",
		token.Type7:  "[",
	},
	// LexSymbol : ∙char_lit
	map[token.Type]string{
		token.Type10: "char_lit",
	},
	// LexSymbol : char_lit ∙
	map[token.Type]string{
		token.Type8:  "]",
		token.Type22: "{",
		token.Type10: "char_lit",
		token.Type23: "|",
		token.Type16: "number",
		token.Type14: "not",
		token.Type0:  "(",
		token.Type2:  ".",
		token.Type9:  "any",
		token.Type24: "}",
		token.Type6:  ">",
		token.Type5:  "<",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type1:  ")",
		token.Type4:  ";",
		token.Type13: "lowcase",
		token.Type7:  "[",
		token.Type12: "letter",
	},
	// LexSymbol : ∙LexBracket
	map[token.Type]string{
		token.Type0:  "(",
		token.Type5:  "<",
		token.Type7:  "[",
		token.Type22: "{",
	},
	// LexSymbol : LexBracket ∙
	map[token.Type]string{
		token.Type1:  ")",
		token.Type4:  ";",
		token.Type13: "lowcase",
		token.Type7:  "[",
		token.Type12: "letter",
		token.Type8:  "]",
		token.Type22: "{",
		token.Type10: "char_lit",
		token.Type9:  "any",
		token.Type23: "|",
		token.Type16: "number",
		token.Type14: "not",
		token.Type0:  "(",
		token.Type2:  ".",
		token.Type21: "upcase",
		token.Type24: "}",
		token.Type6:  ">",
		token.Type5:  "<",
		token.Type18: "space",
	},
	// LexSymbol : ∙not string_lit
	map[token.Type]string{
		token.Type14: "not",
	},
	// LexSymbol : not ∙string_lit
	map[token.Type]string{
		token.Type19: "string_lit",
	},
	// LexSymbol : not string_lit ∙
	map[token.Type]string{
		token.Type8:  "]",
		token.Type22: "{",
		token.Type10: "char_lit",
		token.Type23: "|",
		token.Type16: "number",
		token.Type14: "not",
		token.Type0:  "(",
		token.Type2:  ".",
		token.Type9:  "any",
		token.Type24: "}",
		token.Type6:  ">",
		token.Type5:  "<",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type1:  ")",
		token.Type4:  ";",
		token.Type13: "lowcase",
		token.Type7:  "[",
		token.Type12: "letter",
	},
	// LexSymbol : ∙UnicodeClass
	map[token.Type]string{
		token.Type12: "letter",
		token.Type13: "lowcase",
		token.Type16: "number",
		token.Type18: "space",
		token.Type21: "upcase",
	},
	// LexSymbol : UnicodeClass ∙
	map[token.Type]string{
		token.Type14: "not",
		token.Type0:  "(",
		token.Type2:  ".",
		token.Type9:  "any",
		token.Type23: "|",
		token.Type16: "number",
		token.Type6:  ">",
		token.Type5:  "<",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type24: "}",
		token.Type13: "lowcase",
		token.Type7:  "[",
		token.Type12: "letter",
		token.Type1:  ")",
		token.Type4:  ";",
		token.Type10: "char_lit",
		token.Type8:  "]",
		token.Type22: "{",
	},
	// LexZeroOrMore : ∙{ LexAlternates }
	map[token.Type]string{
		token.Type22: "{",
	},
	// LexZeroOrMore : { ∙LexAlternates }
	map[token.Type]string{
		token.Type0:  "(",
		token.Type2:  ".",
		token.Type5:  "<",
		token.Type7:  "[",
		token.Type9:  "any",
		token.Type10: "char_lit",
		token.Type12: "letter",
		token.Type13: "lowcase",
		token.Type14: "not",
		token.Type16: "number",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type22: "{",
	},
	// LexZeroOrMore : { LexAlternates ∙}
	map[token.Type]string{
		token.Type24: "}",
	},
	// LexZeroOrMore : { LexAlternates } ∙
	map[token.Type]string{
		token.Type24: "}",
		token.Type2:  ".",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type16: "number",
		token.Type5:  "<",
		token.Type22: "{",
		token.Type10: "char_lit",
		token.Type7:  "[",
		token.Type6:  ">",
		token.Type4:  ";",
		token.Type8:  "]",
		token.Type12: "letter",
		token.Type9:  "any",
		token.Type14: "not",
		token.Type13: "lowcase",
		token.Type1:  ")",
		token.Type0:  "(",
		token.Type23: "|",
	},
	// NT : ∙nt
	map[token.Type]string{
		token.Type15: "nt",
	},
	// NT : nt ∙
	map[token.Type]string{
		token.Type3:  ":",
		token.Type23: "|",
		token.Type15: "nt",
		token.Type20: "tokid",
		token.Type19: "string_lit",
		token.Type4:  ";",
	},
	// Package : ∙package string_lit
	map[token.Type]string{
		token.Type17: "package",
	},
	// Package : package ∙string_lit
	map[token.Type]string{
		token.Type19: "string_lit",
	},
	// Package : package string_lit ∙
	map[token.Type]string{
		token.Type20: "tokid",
		token.Type15: "nt",
	},
	// RegExp : ∙LexSymbol
	map[token.Type]string{
		token.Type0:  "(",
		token.Type2:  ".",
		token.Type5:  "<",
		token.Type7:  "[",
		token.Type9:  "any",
		token.Type10: "char_lit",
		token.Type12: "letter",
		token.Type13: "lowcase",
		token.Type14: "not",
		token.Type16: "number",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type22: "{",
	},
	// RegExp : LexSymbol ∙
	map[token.Type]string{
		token.Type4:  ";",
		token.Type8:  "]",
		token.Type24: "}",
		token.Type6:  ">",
		token.Type1:  ")",
		token.Type23: "|",
	},
	// RegExp : ∙LexSymbol RegExp
	map[token.Type]string{
		token.Type0:  "(",
		token.Type2:  ".",
		token.Type5:  "<",
		token.Type7:  "[",
		token.Type9:  "any",
		token.Type10: "char_lit",
		token.Type12: "letter",
		token.Type13: "lowcase",
		token.Type14: "not",
		token.Type16: "number",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type22: "{",
	},
	// RegExp : LexSymbol ∙RegExp
	map[token.Type]string{
		token.Type0:  "(",
		token.Type2:  ".",
		token.Type5:  "<",
		token.Type7:  "[",
		token.Type9:  "any",
		token.Type10: "char_lit",
		token.Type12: "letter",
		token.Type13: "lowcase",
		token.Type14: "not",
		token.Type16: "number",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type22: "{",
	},
	// RegExp : LexSymbol RegExp ∙
	map[token.Type]string{
		token.Type8:  "]",
		token.Type24: "}",
		token.Type6:  ">",
		token.Type1:  ")",
		token.Type23: "|",
		token.Type4:  ";",
	},
	// Rule : ∙LexRule
	map[token.Type]string{
		token.Type20: "tokid",
	},
	// Rule : LexRule ∙
	map[token.Type]string{
		token.EOF:    "EOF",
		token.Type20: "tokid",
		token.Type15: "nt",
	},
	// Rule : ∙SyntaxRule
	map[token.Type]string{
		token.Type15: "nt",
	},
	// Rule : SyntaxRule ∙
	map[token.Type]string{
		token.EOF:    "EOF",
		token.Type20: "tokid",
		token.Type15: "nt",
	},
	// Rules : ∙Rule
	map[token.Type]string{
		token.Type15: "nt",
		token.Type20: "tokid",
	},
	// Rules : Rule ∙
	map[token.Type]string{
		token.EOF: "EOF",
	},
	// Rules : ∙Rule Rules
	map[token.Type]string{
		token.Type15: "nt",
		token.Type20: "tokid",
	},
	// Rules : Rule ∙Rules
	map[token.Type]string{
		token.Type15: "nt",
		token.Type20: "tokid",
	},
	// Rules : Rule Rules ∙
	map[token.Type]string{
		token.EOF: "EOF",
	},
	// SyntaxAlternate : ∙SyntaxSymbols
	map[token.Type]string{
		token.Type15: "nt",
		token.Type19: "string_lit",
		token.Type20: "tokid",
	},
	// SyntaxAlternate : SyntaxSymbols ∙
	map[token.Type]string{
		token.Type23: "|",
		token.Type4:  ";",
	},
	// SyntaxAlternate : ∙empty
	map[token.Type]string{
		token.Type11: "empty",
	},
	// SyntaxAlternate : empty ∙
	map[token.Type]string{
		token.Type4:  ";",
		token.Type23: "|",
	},
	// SyntaxAlternates : ∙SyntaxAlternate
	map[token.Type]string{
		token.Type11: "empty",
		token.Type15: "nt",
		token.Type19: "string_lit",
		token.Type20: "tokid",
	},
	// SyntaxAlternates : SyntaxAlternate ∙
	map[token.Type]string{
		token.Type4: ";",
	},
	// SyntaxAlternates : ∙SyntaxAlternate | SyntaxAlternates
	map[token.Type]string{
		token.Type11: "empty",
		token.Type15: "nt",
		token.Type19: "string_lit",
		token.Type20: "tokid",
	},
	// SyntaxAlternates : SyntaxAlternate ∙| SyntaxAlternates
	map[token.Type]string{
		token.Type23: "|",
	},
	// SyntaxAlternates : SyntaxAlternate | ∙SyntaxAlternates
	map[token.Type]string{
		token.Type11: "empty",
		token.Type15: "nt",
		token.Type19: "string_lit",
		token.Type20: "tokid",
	},
	// SyntaxAlternates : SyntaxAlternate | SyntaxAlternates ∙
	map[token.Type]string{
		token.Type4: ";",
	},
	// SyntaxRule : ∙NT : SyntaxAlternates ;
	map[token.Type]string{
		token.Type15: "nt",
	},
	// SyntaxRule : NT ∙: SyntaxAlternates ;
	map[token.Type]string{
		token.Type3: ":",
	},
	// SyntaxRule : NT : ∙SyntaxAlternates ;
	map[token.Type]string{
		token.Type11: "empty",
		token.Type15: "nt",
		token.Type19: "string_lit",
		token.Type20: "tokid",
	},
	// SyntaxRule : NT : SyntaxAlternates ∙;
	map[token.Type]string{
		token.Type4: ";",
	},
	// SyntaxRule : NT : SyntaxAlternates ; ∙
	map[token.Type]string{
		token.EOF:    "EOF",
		token.Type20: "tokid",
		token.Type15: "nt",
	},
	// SyntaxSymbol : ∙NT
	map[token.Type]string{
		token.Type15: "nt",
	},
	// SyntaxSymbol : NT ∙
	map[token.Type]string{
		token.Type23: "|",
		token.Type15: "nt",
		token.Type20: "tokid",
		token.Type19: "string_lit",
		token.Type4:  ";",
	},
	// SyntaxSymbol : ∙TokID
	map[token.Type]string{
		token.Type20: "tokid",
	},
	// SyntaxSymbol : TokID ∙
	map[token.Type]string{
		token.Type4:  ";",
		token.Type23: "|",
		token.Type15: "nt",
		token.Type20: "tokid",
		token.Type19: "string_lit",
	},
	// SyntaxSymbol : ∙string_lit
	map[token.Type]string{
		token.Type19: "string_lit",
	},
	// SyntaxSymbol : string_lit ∙
	map[token.Type]string{
		token.Type4:  ";",
		token.Type23: "|",
		token.Type15: "nt",
		token.Type20: "tokid",
		token.Type19: "string_lit",
	},
	// SyntaxSymbols : ∙SyntaxSymbol
	map[token.Type]string{
		token.Type15: "nt",
		token.Type19: "string_lit",
		token.Type20: "tokid",
	},
	// SyntaxSymbols : SyntaxSymbol ∙
	map[token.Type]string{
		token.Type4:  ";",
		token.Type23: "|",
	},
	// SyntaxSymbols : ∙SyntaxSymbol SyntaxSymbols
	map[token.Type]string{
		token.Type15: "nt",
		token.Type19: "string_lit",
		token.Type20: "tokid",
	},
	// SyntaxSymbols : SyntaxSymbol ∙SyntaxSymbols
	map[token.Type]string{
		token.Type15: "nt",
		token.Type19: "string_lit",
		token.Type20: "tokid",
	},
	// SyntaxSymbols : SyntaxSymbol SyntaxSymbols ∙
	map[token.Type]string{
		token.Type4:  ";",
		token.Type23: "|",
	},
	// TokID : ∙tokid
	map[token.Type]string{
		token.Type20: "tokid",
	},
	// TokID : tokid ∙
	map[token.Type]string{
		token.Type15: "nt",
		token.Type20: "tokid",
		token.Type19: "string_lit",
		token.Type3:  ":",
		token.Type4:  ";",
		token.Type23: "|",
	},
	// UnicodeClass : ∙letter
	map[token.Type]string{
		token.Type12: "letter",
	},
	// UnicodeClass : letter ∙
	map[token.Type]string{
		token.Type2:  ".",
		token.Type24: "}",
		token.Type5:  "<",
		token.Type4:  ";",
		token.Type13: "lowcase",
		token.Type23: "|",
		token.Type16: "number",
		token.Type0:  "(",
		token.Type7:  "[",
		token.Type8:  "]",
		token.Type22: "{",
		token.Type14: "not",
		token.Type12: "letter",
		token.Type9:  "any",
		token.Type21: "upcase",
		token.Type1:  ")",
		token.Type10: "char_lit",
		token.Type6:  ">",
		token.Type18: "space",
	},
	// UnicodeClass : ∙upcase
	map[token.Type]string{
		token.Type21: "upcase",
	},
	// UnicodeClass : upcase ∙
	map[token.Type]string{
		token.Type8:  "]",
		token.Type22: "{",
		token.Type14: "not",
		token.Type0:  "(",
		token.Type7:  "[",
		token.Type9:  "any",
		token.Type21: "upcase",
		token.Type12: "letter",
		token.Type6:  ">",
		token.Type18: "space",
		token.Type1:  ")",
		token.Type10: "char_lit",
		token.Type5:  "<",
		token.Type4:  ";",
		token.Type13: "lowcase",
		token.Type23: "|",
		token.Type16: "number",
		token.Type2:  ".",
		token.Type24: "}",
	},
	// UnicodeClass : ∙lowcase
	map[token.Type]string{
		token.Type13: "lowcase",
	},
	// UnicodeClass : lowcase ∙
	map[token.Type]string{
		token.Type14: "not",
		token.Type0:  "(",
		token.Type7:  "[",
		token.Type8:  "]",
		token.Type22: "{",
		token.Type9:  "any",
		token.Type21: "upcase",
		token.Type12: "letter",
		token.Type6:  ">",
		token.Type18: "space",
		token.Type1:  ")",
		token.Type10: "char_lit",
		token.Type13: "lowcase",
		token.Type23: "|",
		token.Type16: "number",
		token.Type2:  ".",
		token.Type24: "}",
		token.Type5:  "<",
		token.Type4:  ";",
	},
	// UnicodeClass : ∙number
	map[token.Type]string{
		token.Type16: "number",
	},
	// UnicodeClass : number ∙
	map[token.Type]string{
		token.Type10: "char_lit",
		token.Type6:  ">",
		token.Type18: "space",
		token.Type1:  ")",
		token.Type24: "}",
		token.Type5:  "<",
		token.Type4:  ";",
		token.Type13: "lowcase",
		token.Type23: "|",
		token.Type16: "number",
		token.Type2:  ".",
		token.Type7:  "[",
		token.Type8:  "]",
		token.Type22: "{",
		token.Type14: "not",
		token.Type0:  "(",
		token.Type9:  "any",
		token.Type21: "upcase",
		token.Type12: "letter",
	},
	// UnicodeClass : ∙space
	map[token.Type]string{
		token.Type18: "space",
	},
	// UnicodeClass : space ∙
	map[token.Type]string{
		token.Type21: "upcase",
		token.Type12: "letter",
		token.Type9:  "any",
		token.Type18: "space",
		token.Type1:  ")",
		token.Type10: "char_lit",
		token.Type6:  ">",
		token.Type16: "number",
		token.Type2:  ".",
		token.Type24: "}",
		token.Type5:  "<",
		token.Type4:  ";",
		token.Type13: "lowcase",
		token.Type23: "|",
		token.Type14: "not",
		token.Type0:  "(",
		token.Type7:  "[",
		token.Type8:  "]",
		token.Type22: "{",
	},
}

var followSets = []map[token.Type]string{
	// GoGLL
	map[token.Type]string{
		token.EOF: "EOF",
	},
	// LexAlternates
	map[token.Type]string{
		token.Type1:  ")",
		token.Type8:  "]",
		token.Type24: "}",
		token.Type6:  ">",
	},
	// LexBracket
	map[token.Type]string{
		token.Type1:  ")",
		token.Type7:  "[",
		token.Type12: "letter",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type6:  ">",
		token.Type2:  ".",
		token.Type9:  "any",
		token.Type23: "|",
		token.Type16: "number",
		token.Type5:  "<",
		token.Type4:  ";",
		token.Type22: "{",
		token.Type0:  "(",
		token.Type14: "not",
		token.Type24: "}",
		token.Type13: "lowcase",
		token.Type8:  "]",
		token.Type10: "char_lit",
	},
	// LexGroup
	map[token.Type]string{
		token.Type14: "not",
		token.Type7:  "[",
		token.Type12: "letter",
		token.Type2:  ".",
		token.Type16: "number",
		token.Type5:  "<",
		token.Type4:  ";",
		token.Type24: "}",
		token.Type13: "lowcase",
		token.Type6:  ">",
		token.Type9:  "any",
		token.Type23: "|",
		token.Type8:  "]",
		token.Type10: "char_lit",
		token.Type1:  ")",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type22: "{",
		token.Type0:  "(",
	},
	// LexOneOrMore
	map[token.Type]string{
		token.Type18: "space",
		token.Type4:  ";",
		token.Type9:  "any",
		token.Type8:  "]",
		token.Type10: "char_lit",
		token.Type12: "letter",
		token.Type16: "number",
		token.Type6:  ">",
		token.Type2:  ".",
		token.Type21: "upcase",
		token.Type1:  ")",
		token.Type0:  "(",
		token.Type23: "|",
		token.Type13: "lowcase",
		token.Type14: "not",
		token.Type24: "}",
		token.Type5:  "<",
		token.Type22: "{",
		token.Type7:  "[",
	},
	// LexOptional
	map[token.Type]string{
		token.Type13: "lowcase",
		token.Type14: "not",
		token.Type7:  "[",
		token.Type1:  ")",
		token.Type16: "number",
		token.Type9:  "any",
		token.Type8:  "]",
		token.Type10: "char_lit",
		token.Type12: "letter",
		token.Type21: "upcase",
		token.Type6:  ">",
		token.Type22: "{",
		token.Type0:  "(",
		token.Type24: "}",
		token.Type2:  ".",
		token.Type23: "|",
		token.Type5:  "<",
		token.Type18: "space",
		token.Type4:  ";",
	},
	// LexRule
	map[token.Type]string{
		token.Type20: "tokid",
		token.Type15: "nt",
		token.EOF:    "EOF",
	},
	// LexSymbol
	map[token.Type]string{
		token.Type4:  ";",
		token.Type13: "lowcase",
		token.Type7:  "[",
		token.Type12: "letter",
		token.Type1:  ")",
		token.Type22: "{",
		token.Type10: "char_lit",
		token.Type8:  "]",
		token.Type16: "number",
		token.Type14: "not",
		token.Type0:  "(",
		token.Type2:  ".",
		token.Type9:  "any",
		token.Type23: "|",
		token.Type24: "}",
		token.Type6:  ">",
		token.Type5:  "<",
		token.Type18: "space",
		token.Type21: "upcase",
	},
	// LexZeroOrMore
	map[token.Type]string{
		token.Type7:  "[",
		token.Type6:  ">",
		token.Type4:  ";",
		token.Type8:  "]",
		token.Type12: "letter",
		token.Type9:  "any",
		token.Type14: "not",
		token.Type13: "lowcase",
		token.Type1:  ")",
		token.Type0:  "(",
		token.Type23: "|",
		token.Type22: "{",
		token.Type10: "char_lit",
		token.Type24: "}",
		token.Type2:  ".",
		token.Type18: "space",
		token.Type21: "upcase",
		token.Type16: "number",
		token.Type5:  "<",
	},
	// NT
	map[token.Type]string{
		token.Type4:  ";",
		token.Type3:  ":",
		token.Type23: "|",
		token.Type15: "nt",
		token.Type20: "tokid",
		token.Type19: "string_lit",
	},
	// Package
	map[token.Type]string{
		token.Type20: "tokid",
		token.Type15: "nt",
	},
	// RegExp
	map[token.Type]string{
		token.Type23: "|",
		token.Type4:  ";",
		token.Type8:  "]",
		token.Type24: "}",
		token.Type6:  ">",
		token.Type1:  ")",
	},
	// Rule
	map[token.Type]string{
		token.EOF:    "EOF",
		token.Type20: "tokid",
		token.Type15: "nt",
	},
	// Rules
	map[token.Type]string{
		token.EOF: "EOF",
	},
	// SyntaxAlternate
	map[token.Type]string{
		token.Type23: "|",
		token.Type4:  ";",
	},
	// SyntaxAlternates
	map[token.Type]string{
		token.Type4: ";",
	},
	// SyntaxRule
	map[token.Type]string{
		token.EOF:    "EOF",
		token.Type20: "tokid",
		token.Type15: "nt",
	},
	// SyntaxSymbol
	map[token.Type]string{
		token.Type4:  ";",
		token.Type23: "|",
		token.Type15: "nt",
		token.Type20: "tokid",
		token.Type19: "string_lit",
	},
	// SyntaxSymbols
	map[token.Type]string{
		token.Type4:  ";",
		token.Type23: "|",
	},
	// TokID
	map[token.Type]string{
		token.Type23: "|",
		token.Type15: "nt",
		token.Type20: "tokid",
		token.Type19: "string_lit",
		token.Type3:  ":",
		token.Type4:  ";",
	},
	// UnicodeClass
	map[token.Type]string{
		token.Type6:  ">",
		token.Type18: "space",
		token.Type1:  ")",
		token.Type10: "char_lit",
		token.Type4:  ";",
		token.Type13: "lowcase",
		token.Type23: "|",
		token.Type16: "number",
		token.Type2:  ".",
		token.Type24: "}",
		token.Type5:  "<",
		token.Type22: "{",
		token.Type14: "not",
		token.Type0:  "(",
		token.Type7:  "[",
		token.Type8:  "]",
		token.Type9:  "any",
		token.Type21: "upcase",
		token.Type12: "letter",
	},
}

/*** Errors ***/

type Error struct {
	cI           int
	Slot         slot.Label
	Token        *token.Token
	Line, Column int
}

func (pe *Error) String() string {
	return fmt.Sprintf("Parse Error: %s I[%d]=%s at line %d col %d",
		pe.Slot, pe.cI, pe.Token, pe.Line, pe.Column)
}

func parseError(slot slot.Label, i int) {
	pe := &Error{cI: i, Slot: slot, Token: lex.Tokens[i]}
	parseErrors = append(parseErrors, pe)
}

func sortParseErrors() {
	sort.Slice(parseErrors,
		func(i, j int) bool {
			return parseErrors[j].Token.Lext < parseErrors[i].Token.Lext
		})
	for _, pe := range parseErrors {
		pe.Line, pe.Column = lex.GetLineColumn(pe.Token.Lext)
	}
}

func parseErrorError(err error) {
	fmt.Printf("Error: %s\n", err)
	os.Exit(1)
}
