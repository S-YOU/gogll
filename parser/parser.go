// Package parser is generated by gogll. Do not edit.
//
//  Copyright 2019 Marius Ackerman
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
package parser

import (
	"bytes"
	"fmt"
	"os"
	"sort"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/goccmack/gogll/goutil/bsr"
	"github.com/goccmack/gogll/goutil/md"
	"github.com/goccmack/gogll/parser/slot"

	"io/ioutil"
)

func ParseFile(fname string) (error, []*ParseError) {
	var buf []byte
	var err error
	if strings.HasSuffix(fname, ".md") {
		var str string
		str, err = md.GetSource(fname)
		if err != nil {
			parseErrorError(err)
		}
		buf = []byte(str)
	} else {
		buf, err = ioutil.ReadFile(fname)
		if err != nil {
			parseErrorError(err)
		}
	}
	return Parse(buf)
}

var (
	cI    = 0
	sz    = 0
	nextI = ""
	r     rune

	R *descriptors
	U *descriptors

	popped   map[poppedNode]bool
	crf      map[clusterNode][]*crfNode
	crfNodes map[crfNode]*crfNode

	input       []byte
	parseErrors []*ParseError
)

func initParser(I []byte) {
	input = I
	cI, nextI, sz = 0, "", 0
	R, U = &descriptors{}, &descriptors{}
	popped = make(map[poppedNode]bool)
	crf = map[clusterNode][]*crfNode{
		{"GoGLL", 0}: {},
	}
	crfNodes = map[crfNode]*crfNode{}
	bsr.Init("GoGLL", I)
	parseErrors = nil
}

func Parse(I []byte) (error, []*ParseError) {
	initParser(I)
	var L slot.Label
	m, cU := len(I), 0
	nextI, r, sz = decodeRune(I[cI:])
	ntAdd("GoGLL", 0)
	// DumpDescriptors()
	for !R.empty() {
		L, cU, cI = R.remove()
		nextI, r, sz = decodeRune(I[cI:])

		// fmt.Println()
		// fmt.Printf("L:%s, cI:%d, I[cI]:%s, cU:%d\n", L, cI, nextI, cU)
		// DumpDescriptors()

		switch L {
		case slot.Alternate0R0: // Alternate : ∙Symbols

			call(slot.Alternate0R1, cU, cI)
		case slot.Alternate0R1: // Alternate : Symbols ∙

			if followAlternate() {
				rtn("Alternate", cU, cI)
			}
		case slot.Alternate1R0: // Alternate : ∙e m p t y

			bsr.Add(slot.Alternate1R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Alternate1R1]() {
				parseError(slot.Alternate1R1, cI)
				break
			}

			bsr.Add(slot.Alternate1R2, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Alternate1R2]() {
				parseError(slot.Alternate1R2, cI)
				break
			}

			bsr.Add(slot.Alternate1R3, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Alternate1R3]() {
				parseError(slot.Alternate1R3, cI)
				break
			}

			bsr.Add(slot.Alternate1R4, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Alternate1R4]() {
				parseError(slot.Alternate1R4, cI)
				break
			}

			bsr.Add(slot.Alternate1R5, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followAlternate() {
				rtn("Alternate", cU, cI)
			}
		case slot.Alternates0R0: // Alternates : ∙Alternate

			call(slot.Alternates0R1, cU, cI)
		case slot.Alternates0R1: // Alternates : Alternate ∙

			if followAlternates() {
				rtn("Alternates", cU, cI)
			}
		case slot.Alternates1R0: // Alternates : ∙Alternate SepE | SepE Alternates

			call(slot.Alternates1R1, cU, cI)
		case slot.Alternates1R1: // Alternates : Alternate ∙SepE | SepE Alternates

			if !testSelect[slot.Alternates1R1]() {
				parseError(slot.Alternates1R1, cI)
				break
			}

			call(slot.Alternates1R2, cU, cI)
		case slot.Alternates1R2: // Alternates : Alternate SepE ∙| SepE Alternates

			if !testSelect[slot.Alternates1R2]() {
				parseError(slot.Alternates1R2, cI)
				break
			}

			bsr.Add(slot.Alternates1R3, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Alternates1R3]() {
				parseError(slot.Alternates1R3, cI)
				break
			}

			call(slot.Alternates1R4, cU, cI)
		case slot.Alternates1R4: // Alternates : Alternate SepE | SepE ∙Alternates

			if !testSelect[slot.Alternates1R4]() {
				parseError(slot.Alternates1R4, cI)
				break
			}

			call(slot.Alternates1R5, cU, cI)
		case slot.Alternates1R5: // Alternates : Alternate SepE | SepE Alternates ∙

			if followAlternates() {
				rtn("Alternates", cU, cI)
			}
		case slot.CharLiteral0R0: // CharLiteral : ∙' \\ anyof('\"\\\n\r\t) '

			bsr.Add(slot.CharLiteral0R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.CharLiteral0R1]() {
				parseError(slot.CharLiteral0R1, cI)
				break
			}

			bsr.Add(slot.CharLiteral0R2, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.CharLiteral0R2]() {
				parseError(slot.CharLiteral0R2, cI)
				break
			}

			bsr.Add(slot.CharLiteral0R3, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.CharLiteral0R3]() {
				parseError(slot.CharLiteral0R3, cI)
				break
			}

			bsr.Add(slot.CharLiteral0R4, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followCharLiteral() {
				rtn("CharLiteral", cU, cI)
			}
		case slot.CharLiteral1R0: // CharLiteral : ∙' any '

			bsr.Add(slot.CharLiteral1R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.CharLiteral1R1]() {
				parseError(slot.CharLiteral1R1, cI)
				break
			}

			bsr.Add(slot.CharLiteral1R2, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.CharLiteral1R2]() {
				parseError(slot.CharLiteral1R2, cI)
				break
			}

			bsr.Add(slot.CharLiteral1R3, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followCharLiteral() {
				rtn("CharLiteral", cU, cI)
			}
		case slot.EscapedChar0R0: // EscapedChar : ∙"

			bsr.Add(slot.EscapedChar0R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followEscapedChar() {
				rtn("EscapedChar", cU, cI)
			}
		case slot.EscapedChar1R0: // EscapedChar : ∙n

			bsr.Add(slot.EscapedChar1R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followEscapedChar() {
				rtn("EscapedChar", cU, cI)
			}
		case slot.EscapedChar2R0: // EscapedChar : ∙r

			bsr.Add(slot.EscapedChar2R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followEscapedChar() {
				rtn("EscapedChar", cU, cI)
			}
		case slot.EscapedChar3R0: // EscapedChar : ∙t

			bsr.Add(slot.EscapedChar3R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followEscapedChar() {
				rtn("EscapedChar", cU, cI)
			}
		case slot.EscapedChar4R0: // EscapedChar : ∙\\

			bsr.Add(slot.EscapedChar4R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followEscapedChar() {
				rtn("EscapedChar", cU, cI)
			}
		case slot.GoGLL0R0: // GoGLL : ∙SepE Package Sep Rules SepE

			call(slot.GoGLL0R1, cU, cI)
		case slot.GoGLL0R1: // GoGLL : SepE ∙Package Sep Rules SepE

			if !testSelect[slot.GoGLL0R1]() {
				parseError(slot.GoGLL0R1, cI)
				break
			}

			call(slot.GoGLL0R2, cU, cI)
		case slot.GoGLL0R2: // GoGLL : SepE Package ∙Sep Rules SepE

			if !testSelect[slot.GoGLL0R2]() {
				parseError(slot.GoGLL0R2, cI)
				break
			}

			call(slot.GoGLL0R3, cU, cI)
		case slot.GoGLL0R3: // GoGLL : SepE Package Sep ∙Rules SepE

			if !testSelect[slot.GoGLL0R3]() {
				parseError(slot.GoGLL0R3, cI)
				break
			}

			call(slot.GoGLL0R4, cU, cI)
		case slot.GoGLL0R4: // GoGLL : SepE Package Sep Rules ∙SepE

			if !testSelect[slot.GoGLL0R4]() {
				parseError(slot.GoGLL0R4, cI)
				break
			}

			call(slot.GoGLL0R5, cU, cI)
		case slot.GoGLL0R5: // GoGLL : SepE Package Sep Rules SepE ∙

			if followGoGLL() {
				rtn("GoGLL", cU, cI)
			}
		case slot.Head0R0: // Head : ∙* NTID

			bsr.Add(slot.Head0R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Head0R1]() {
				parseError(slot.Head0R1, cI)
				break
			}

			call(slot.Head0R2, cU, cI)
		case slot.Head0R2: // Head : * NTID ∙

			if followHead() {
				rtn("Head", cU, cI)
			}
		case slot.Head1R0: // Head : ∙NTID

			call(slot.Head1R1, cU, cI)
		case slot.Head1R1: // Head : NTID ∙

			if followHead() {
				rtn("Head", cU, cI)
			}
		case slot.NTChar0R0: // NTChar : ∙letter

			bsr.Add(slot.NTChar0R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followNTChar() {
				rtn("NTChar", cU, cI)
			}
		case slot.NTChar1R0: // NTChar : ∙number

			bsr.Add(slot.NTChar1R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followNTChar() {
				rtn("NTChar", cU, cI)
			}
		case slot.NTChar2R0: // NTChar : ∙anyof(!#$%&*+-=@^_)

			bsr.Add(slot.NTChar2R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followNTChar() {
				rtn("NTChar", cU, cI)
			}
		case slot.NTChars0R0: // NTChars : ∙NTChar

			call(slot.NTChars0R1, cU, cI)
		case slot.NTChars0R1: // NTChars : NTChar ∙

			if followNTChars() {
				rtn("NTChars", cU, cI)
			}
		case slot.NTChars1R0: // NTChars : ∙NTChar NTChars

			call(slot.NTChars1R1, cU, cI)
		case slot.NTChars1R1: // NTChars : NTChar ∙NTChars

			if !testSelect[slot.NTChars1R1]() {
				parseError(slot.NTChars1R1, cI)
				break
			}

			call(slot.NTChars1R2, cU, cI)
		case slot.NTChars1R2: // NTChars : NTChar NTChars ∙

			if followNTChars() {
				rtn("NTChars", cU, cI)
			}
		case slot.NTID0R0: // NTID : ∙letter

			bsr.Add(slot.NTID0R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followNTID() {
				rtn("NTID", cU, cI)
			}
		case slot.NTID1R0: // NTID : ∙letter NTChars

			bsr.Add(slot.NTID1R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.NTID1R1]() {
				parseError(slot.NTID1R1, cI)
				break
			}

			call(slot.NTID1R2, cU, cI)
		case slot.NTID1R2: // NTID : letter NTChars ∙

			if followNTID() {
				rtn("NTID", cU, cI)
			}
		case slot.NonTerminal0R0: // NonTerminal : ∙NTID

			call(slot.NonTerminal0R1, cU, cI)
		case slot.NonTerminal0R1: // NonTerminal : NTID ∙

			if followNonTerminal() {
				rtn("NonTerminal", cU, cI)
			}
		case slot.Package0R0: // Package : ∙p a c k a g e Sep String

			bsr.Add(slot.Package0R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Package0R1]() {
				parseError(slot.Package0R1, cI)
				break
			}

			bsr.Add(slot.Package0R2, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Package0R2]() {
				parseError(slot.Package0R2, cI)
				break
			}

			bsr.Add(slot.Package0R3, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Package0R3]() {
				parseError(slot.Package0R3, cI)
				break
			}

			bsr.Add(slot.Package0R4, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Package0R4]() {
				parseError(slot.Package0R4, cI)
				break
			}

			bsr.Add(slot.Package0R5, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Package0R5]() {
				parseError(slot.Package0R5, cI)
				break
			}

			bsr.Add(slot.Package0R6, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Package0R6]() {
				parseError(slot.Package0R6, cI)
				break
			}

			bsr.Add(slot.Package0R7, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Package0R7]() {
				parseError(slot.Package0R7, cI)
				break
			}

			call(slot.Package0R8, cU, cI)
		case slot.Package0R8: // Package : p a c k a g e Sep ∙String

			if !testSelect[slot.Package0R8]() {
				parseError(slot.Package0R8, cI)
				break
			}

			call(slot.Package0R9, cU, cI)
		case slot.Package0R9: // Package : p a c k a g e Sep String ∙

			if followPackage() {
				rtn("Package", cU, cI)
			}
		case slot.Rule0R0: // Rule : ∙Head SepE : SepE Alternates SepE ;

			call(slot.Rule0R1, cU, cI)
		case slot.Rule0R1: // Rule : Head ∙SepE : SepE Alternates SepE ;

			if !testSelect[slot.Rule0R1]() {
				parseError(slot.Rule0R1, cI)
				break
			}

			call(slot.Rule0R2, cU, cI)
		case slot.Rule0R2: // Rule : Head SepE ∙: SepE Alternates SepE ;

			if !testSelect[slot.Rule0R2]() {
				parseError(slot.Rule0R2, cI)
				break
			}

			bsr.Add(slot.Rule0R3, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Rule0R3]() {
				parseError(slot.Rule0R3, cI)
				break
			}

			call(slot.Rule0R4, cU, cI)
		case slot.Rule0R4: // Rule : Head SepE : SepE ∙Alternates SepE ;

			if !testSelect[slot.Rule0R4]() {
				parseError(slot.Rule0R4, cI)
				break
			}

			call(slot.Rule0R5, cU, cI)
		case slot.Rule0R5: // Rule : Head SepE : SepE Alternates ∙SepE ;

			if !testSelect[slot.Rule0R5]() {
				parseError(slot.Rule0R5, cI)
				break
			}

			call(slot.Rule0R6, cU, cI)
		case slot.Rule0R6: // Rule : Head SepE : SepE Alternates SepE ∙;

			if !testSelect[slot.Rule0R6]() {
				parseError(slot.Rule0R6, cI)
				break
			}

			bsr.Add(slot.Rule0R7, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followRule() {
				rtn("Rule", cU, cI)
			}
		case slot.Rules0R0: // Rules : ∙Rule

			call(slot.Rules0R1, cU, cI)
		case slot.Rules0R1: // Rules : Rule ∙

			if followRules() {
				rtn("Rules", cU, cI)
			}
		case slot.Rules1R0: // Rules : ∙Rule SepE Rules

			call(slot.Rules1R1, cU, cI)
		case slot.Rules1R1: // Rules : Rule ∙SepE Rules

			if !testSelect[slot.Rules1R1]() {
				parseError(slot.Rules1R1, cI)
				break
			}

			call(slot.Rules1R2, cU, cI)
		case slot.Rules1R2: // Rules : Rule SepE ∙Rules

			if !testSelect[slot.Rules1R2]() {
				parseError(slot.Rules1R2, cI)
				break
			}

			call(slot.Rules1R3, cU, cI)
		case slot.Rules1R3: // Rules : Rule SepE Rules ∙

			if followRules() {
				rtn("Rules", cU, cI)
			}
		case slot.Sep0R0: // Sep : ∙SepChar

			call(slot.Sep0R1, cU, cI)
		case slot.Sep0R1: // Sep : SepChar ∙

			if followSep() {
				rtn("Sep", cU, cI)
			}
		case slot.Sep1R0: // Sep : ∙SepChar Sep

			call(slot.Sep1R1, cU, cI)
		case slot.Sep1R1: // Sep : SepChar ∙Sep

			if !testSelect[slot.Sep1R1]() {
				parseError(slot.Sep1R1, cI)
				break
			}

			call(slot.Sep1R2, cU, cI)
		case slot.Sep1R2: // Sep : SepChar Sep ∙

			if followSep() {
				rtn("Sep", cU, cI)
			}
		case slot.SepChar0R0: // SepChar : ∙space

			bsr.Add(slot.SepChar0R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followSepChar() {
				rtn("SepChar", cU, cI)
			}
		case slot.SepChar1R0: // SepChar : ∙anyof(\n\r\t)

			bsr.Add(slot.SepChar1R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followSepChar() {
				rtn("SepChar", cU, cI)
			}
		case slot.SepE0R0: // SepE : ∙Sep

			call(slot.SepE0R1, cU, cI)
		case slot.SepE0R1: // SepE : Sep ∙

			if followSepE() {
				rtn("SepE", cU, cI)
			}
		case slot.SepE1R0: // SepE : ∙
			bsr.AddEmpty(slot.SepE1R0, cI)

			if followSepE() {
				rtn("SepE", cU, cI)
			}
		case slot.String0R0: // String : ∙\" StringChars \"

			bsr.Add(slot.String0R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.String0R1]() {
				parseError(slot.String0R1, cI)
				break
			}

			call(slot.String0R2, cU, cI)
		case slot.String0R2: // String : \" StringChars ∙\"

			if !testSelect[slot.String0R2]() {
				parseError(slot.String0R2, cI)
				break
			}

			bsr.Add(slot.String0R3, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followString() {
				rtn("String", cU, cI)
			}
		case slot.StringChars0R0: // StringChars : ∙not(\"\\) StringChars

			bsr.Add(slot.StringChars0R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.StringChars0R1]() {
				parseError(slot.StringChars0R1, cI)
				break
			}

			call(slot.StringChars0R2, cU, cI)
		case slot.StringChars0R2: // StringChars : not(\"\\) StringChars ∙

			if followStringChars() {
				rtn("StringChars", cU, cI)
			}
		case slot.StringChars1R0: // StringChars : ∙\\ EscapedChar StringChars

			bsr.Add(slot.StringChars1R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.StringChars1R1]() {
				parseError(slot.StringChars1R1, cI)
				break
			}

			call(slot.StringChars1R2, cU, cI)
		case slot.StringChars1R2: // StringChars : \\ EscapedChar ∙StringChars

			if !testSelect[slot.StringChars1R2]() {
				parseError(slot.StringChars1R2, cI)
				break
			}

			call(slot.StringChars1R3, cU, cI)
		case slot.StringChars1R3: // StringChars : \\ EscapedChar StringChars ∙

			if followStringChars() {
				rtn("StringChars", cU, cI)
			}
		case slot.StringChars2R0: // StringChars : ∙
			bsr.AddEmpty(slot.StringChars2R0, cI)

			if followStringChars() {
				rtn("StringChars", cU, cI)
			}
		case slot.Symbol0R0: // Symbol : ∙NonTerminal

			call(slot.Symbol0R1, cU, cI)
		case slot.Symbol0R1: // Symbol : NonTerminal ∙

			if followSymbol() {
				rtn("Symbol", cU, cI)
			}
		case slot.Symbol1R0: // Symbol : ∙Terminal

			call(slot.Symbol1R1, cU, cI)
		case slot.Symbol1R1: // Symbol : Terminal ∙

			if followSymbol() {
				rtn("Symbol", cU, cI)
			}
		case slot.Symbols0R0: // Symbols : ∙Symbol Sep Symbols

			call(slot.Symbols0R1, cU, cI)
		case slot.Symbols0R1: // Symbols : Symbol ∙Sep Symbols

			if !testSelect[slot.Symbols0R1]() {
				parseError(slot.Symbols0R1, cI)
				break
			}

			call(slot.Symbols0R2, cU, cI)
		case slot.Symbols0R2: // Symbols : Symbol Sep ∙Symbols

			if !testSelect[slot.Symbols0R2]() {
				parseError(slot.Symbols0R2, cI)
				break
			}

			call(slot.Symbols0R3, cU, cI)
		case slot.Symbols0R3: // Symbols : Symbol Sep Symbols ∙

			if followSymbols() {
				rtn("Symbols", cU, cI)
			}
		case slot.Symbols1R0: // Symbols : ∙Symbol

			call(slot.Symbols1R1, cU, cI)
		case slot.Symbols1R1: // Symbols : Symbol ∙

			if followSymbols() {
				rtn("Symbols", cU, cI)
			}
		case slot.Terminal0R0: // Terminal : ∙a n y

			bsr.Add(slot.Terminal0R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal0R1]() {
				parseError(slot.Terminal0R1, cI)
				break
			}

			bsr.Add(slot.Terminal0R2, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal0R2]() {
				parseError(slot.Terminal0R2, cI)
				break
			}

			bsr.Add(slot.Terminal0R3, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followTerminal() {
				rtn("Terminal", cU, cI)
			}
		case slot.Terminal1R0: // Terminal : ∙a n y o f Sep String

			bsr.Add(slot.Terminal1R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal1R1]() {
				parseError(slot.Terminal1R1, cI)
				break
			}

			bsr.Add(slot.Terminal1R2, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal1R2]() {
				parseError(slot.Terminal1R2, cI)
				break
			}

			bsr.Add(slot.Terminal1R3, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal1R3]() {
				parseError(slot.Terminal1R3, cI)
				break
			}

			bsr.Add(slot.Terminal1R4, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal1R4]() {
				parseError(slot.Terminal1R4, cI)
				break
			}

			bsr.Add(slot.Terminal1R5, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal1R5]() {
				parseError(slot.Terminal1R5, cI)
				break
			}

			call(slot.Terminal1R6, cU, cI)
		case slot.Terminal1R6: // Terminal : a n y o f Sep ∙String

			if !testSelect[slot.Terminal1R6]() {
				parseError(slot.Terminal1R6, cI)
				break
			}

			call(slot.Terminal1R7, cU, cI)
		case slot.Terminal1R7: // Terminal : a n y o f Sep String ∙

			if followTerminal() {
				rtn("Terminal", cU, cI)
			}
		case slot.Terminal2R0: // Terminal : ∙l e t t e r

			bsr.Add(slot.Terminal2R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal2R1]() {
				parseError(slot.Terminal2R1, cI)
				break
			}

			bsr.Add(slot.Terminal2R2, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal2R2]() {
				parseError(slot.Terminal2R2, cI)
				break
			}

			bsr.Add(slot.Terminal2R3, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal2R3]() {
				parseError(slot.Terminal2R3, cI)
				break
			}

			bsr.Add(slot.Terminal2R4, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal2R4]() {
				parseError(slot.Terminal2R4, cI)
				break
			}

			bsr.Add(slot.Terminal2R5, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal2R5]() {
				parseError(slot.Terminal2R5, cI)
				break
			}

			bsr.Add(slot.Terminal2R6, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followTerminal() {
				rtn("Terminal", cU, cI)
			}
		case slot.Terminal3R0: // Terminal : ∙n u m b e r

			bsr.Add(slot.Terminal3R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal3R1]() {
				parseError(slot.Terminal3R1, cI)
				break
			}

			bsr.Add(slot.Terminal3R2, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal3R2]() {
				parseError(slot.Terminal3R2, cI)
				break
			}

			bsr.Add(slot.Terminal3R3, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal3R3]() {
				parseError(slot.Terminal3R3, cI)
				break
			}

			bsr.Add(slot.Terminal3R4, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal3R4]() {
				parseError(slot.Terminal3R4, cI)
				break
			}

			bsr.Add(slot.Terminal3R5, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal3R5]() {
				parseError(slot.Terminal3R5, cI)
				break
			}

			bsr.Add(slot.Terminal3R6, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followTerminal() {
				rtn("Terminal", cU, cI)
			}
		case slot.Terminal4R0: // Terminal : ∙s p a c e

			bsr.Add(slot.Terminal4R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal4R1]() {
				parseError(slot.Terminal4R1, cI)
				break
			}

			bsr.Add(slot.Terminal4R2, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal4R2]() {
				parseError(slot.Terminal4R2, cI)
				break
			}

			bsr.Add(slot.Terminal4R3, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal4R3]() {
				parseError(slot.Terminal4R3, cI)
				break
			}

			bsr.Add(slot.Terminal4R4, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal4R4]() {
				parseError(slot.Terminal4R4, cI)
				break
			}

			bsr.Add(slot.Terminal4R5, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followTerminal() {
				rtn("Terminal", cU, cI)
			}
		case slot.Terminal5R0: // Terminal : ∙u p c a s e

			bsr.Add(slot.Terminal5R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal5R1]() {
				parseError(slot.Terminal5R1, cI)
				break
			}

			bsr.Add(slot.Terminal5R2, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal5R2]() {
				parseError(slot.Terminal5R2, cI)
				break
			}

			bsr.Add(slot.Terminal5R3, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal5R3]() {
				parseError(slot.Terminal5R3, cI)
				break
			}

			bsr.Add(slot.Terminal5R4, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal5R4]() {
				parseError(slot.Terminal5R4, cI)
				break
			}

			bsr.Add(slot.Terminal5R5, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal5R5]() {
				parseError(slot.Terminal5R5, cI)
				break
			}

			bsr.Add(slot.Terminal5R6, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followTerminal() {
				rtn("Terminal", cU, cI)
			}
		case slot.Terminal6R0: // Terminal : ∙l o w c a s e

			bsr.Add(slot.Terminal6R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal6R1]() {
				parseError(slot.Terminal6R1, cI)
				break
			}

			bsr.Add(slot.Terminal6R2, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal6R2]() {
				parseError(slot.Terminal6R2, cI)
				break
			}

			bsr.Add(slot.Terminal6R3, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal6R3]() {
				parseError(slot.Terminal6R3, cI)
				break
			}

			bsr.Add(slot.Terminal6R4, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal6R4]() {
				parseError(slot.Terminal6R4, cI)
				break
			}

			bsr.Add(slot.Terminal6R5, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal6R5]() {
				parseError(slot.Terminal6R5, cI)
				break
			}

			bsr.Add(slot.Terminal6R6, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal6R6]() {
				parseError(slot.Terminal6R6, cI)
				break
			}

			bsr.Add(slot.Terminal6R7, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if followTerminal() {
				rtn("Terminal", cU, cI)
			}
		case slot.Terminal7R0: // Terminal : ∙n o t Sep String

			bsr.Add(slot.Terminal7R1, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal7R1]() {
				parseError(slot.Terminal7R1, cI)
				break
			}

			bsr.Add(slot.Terminal7R2, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal7R2]() {
				parseError(slot.Terminal7R2, cI)
				break
			}

			bsr.Add(slot.Terminal7R3, cU, cI, cI+sz)
			cI += sz
			nextI, r, sz = decodeRune(I[cI:])
			if !testSelect[slot.Terminal7R3]() {
				parseError(slot.Terminal7R3, cI)
				break
			}

			call(slot.Terminal7R4, cU, cI)
		case slot.Terminal7R4: // Terminal : n o t Sep ∙String

			if !testSelect[slot.Terminal7R4]() {
				parseError(slot.Terminal7R4, cI)
				break
			}

			call(slot.Terminal7R5, cU, cI)
		case slot.Terminal7R5: // Terminal : n o t Sep String ∙

			if followTerminal() {
				rtn("Terminal", cU, cI)
			}
		case slot.Terminal8R0: // Terminal : ∙CharLiteral

			call(slot.Terminal8R1, cU, cI)
		case slot.Terminal8R1: // Terminal : CharLiteral ∙

			if followTerminal() {
				rtn("Terminal", cU, cI)
			}
		case slot.Terminal9R0: // Terminal : ∙String

			call(slot.Terminal9R1, cU, cI)
		case slot.Terminal9R1: // Terminal : String ∙

			if followTerminal() {
				rtn("Terminal", cU, cI)
			}

		default:
			panic("This must not happen")
		}
	}
	if !bsr.Contain("GoGLL", 0, m) {
		sortParseErrors(I)
		err := fmt.Errorf("Error: Parse Failed right extent=%d, m=%d",
			bsr.GetRightExtent(), len(I))
		return err, parseErrors
	}
	return nil, nil
}

func ntAdd(nt string, j int) {
	// fmt.Printf("ntAdd(%s, %d)\n", nt, j)
	failed := true
	for _, l := range slot.GetAlternates(nt) {
		if testSelect[l]() {
			dscAdd(l, j, j)
		} else {
			failed = false
		}
	}
	if failed {
		for _, l := range slot.GetAlternates(nt) {
			parseError(l, j)
		}
	}
}

/*** Call Return Forest ***/

type poppedNode struct {
	X    string
	k, j int
}

type clusterNode struct {
	X string
	k int
}

type crfNode struct {
	L slot.Label
	i int
}

/*
suppose that L is Y ::=αX ·β
if there is no CRF node labelled (L,i)
	create one let u be the CRF node labelled (L,i)
if there is no CRF node labelled (X, j) {
	create a CRF node v labelled (X, j)
	create an edge from v to u
	ntAdd(X, j)
} else {
	let v be the CRF node labelled (X, j)
	if there is not an edge from v to u {
		create an edge from v to u
		for all ((X, j,h)∈P) {
			dscAdd(L, i, h);
			bsrAdd(L, i, j, h)
		}
	}
}
*/
func call(L slot.Label, i, j int) {
	// fmt.Printf("call(%s,%d,%d)\n", L,i,j)
	u, exist := crfNodes[crfNode{L, i}]
	// fmt.Printf("  u exist=%t\n", exist)
	if !exist {
		u = &crfNode{L, i}
		crfNodes[*u] = u
	}
	X := L.Symbols()[L.Pos()-1]
	ndV := clusterNode{X, j}
	v, exist := crf[ndV]
	if !exist {
		// fmt.Println("  v !exist")
		crf[ndV] = []*crfNode{u}
		ntAdd(X, j)
	} else {
		// fmt.Println("  v exist")
		if !existEdge(v, u) {
			// fmt.Printf("  !existEdge(%v)\n", u)
			crf[ndV] = append(v, u)
			// fmt.Printf("|popped|=%d\n", len(popped))
			for pnd, _ := range popped {
				if pnd.X == X && pnd.k == j {
					dscAdd(L, i, pnd.j)
					bsr.Add(L, i, j, pnd.j)
				}
			}
		}
	}
}

func existEdge(nds []*crfNode, nd *crfNode) bool {
	for _, nd1 := range nds {
		if nd1 == nd {
			return true
		}
	}
	return false
}

func rtn(X string, k, j int) {
	// fmt.Printf("rtn(%s,%d,%d)\n", X,k,j)
	p := poppedNode{X, k, j}
	if _, exist := popped[p]; !exist {
		popped[p] = true
		for _, nd := range crf[clusterNode{X, k}] {
			dscAdd(nd.L, nd.i, j)
			bsr.Add(nd.L, nd.i, k, j)
		}
	}
}

func CRFString() string {
	buf := new(bytes.Buffer)
	buf.WriteString("CRF: {")
	for cn, nds := range crf {
		for _, nd := range nds {
			fmt.Fprintf(buf, "%s->%s, ", cn, nd)
		}
	}
	buf.WriteString("}")
	return buf.String()
}

func (cn clusterNode) String() string {
	return fmt.Sprintf("(%s,%d)", cn.X, cn.k)
}

func (n crfNode) String() string {
	return fmt.Sprintf("(%s,%d)", n.L.String(), n.i)
}

func PoppedString() string {
	buf := new(bytes.Buffer)
	buf.WriteString("Popped: {")
	for p, _ := range popped {
		fmt.Fprintf(buf, "(%s,%d,%d) ", p.X, p.k, p.j)
	}
	buf.WriteString("}")
	return buf.String()
}

/*** descriptors ***/

type descriptors struct {
	set []*descriptor
}

func (ds *descriptors) contain(d *descriptor) bool {
	for _, d1 := range ds.set {
		if d1 == d {
			return true
		}
	}
	return false
}

func (ds *descriptors) empty() bool {
	return len(ds.set) == 0
}

func (ds *descriptors) String() string {
	buf := new(bytes.Buffer)
	buf.WriteString("{")
	for i, d := range ds.set {
		if i > 0 {
			buf.WriteString("; ")
		}
		fmt.Fprintf(buf, "%s", d)
	}
	buf.WriteString("}")
	return buf.String()
}

type descriptor struct {
	L slot.Label
	k int
	i int
}

func (d *descriptor) String() string {
	return fmt.Sprintf("%s,%d,%d", d.L, d.k, d.i)
}

func dscAdd(L slot.Label, k, i int) {
	// fmt.Printf("dscAdd(%s,%d,%d)\n", L, k, i)
	d := &descriptor{L, k, i}
	if !U.contain(d) {
		R.set = append(R.set, d)
		U.set = append(U.set, d)
	}
}

func (ds *descriptors) remove() (L slot.Label, k, i int) {
	d := ds.set[len(ds.set)-1]
	ds.set = ds.set[:len(ds.set)-1]
	// fmt.Printf("remove: %s,%d,%d\n", d.L, d.k, d.i)
	return d.L, d.k, d.i
}

func DumpDescriptors() {
	DumpR()
	DumpU()
}

func DumpR() {
	fmt.Println("R:")
	for _, d := range R.set {
		fmt.Printf(" %s\n", d)
	}
}

func DumpU() {
	fmt.Println("U:")
	for _, d := range U.set {
		fmt.Printf(" %s\n", d)
	}
}

/*** Rune decoding ***/
func decodeRune(str []byte) (string, rune, int) {
	if len(str) == 0 {
		return "$", '$', 0
	}
	r, sz := utf8.DecodeRune(str)
	if r == utf8.RuneError {
		panic(fmt.Sprintf("Rune error: %s", str))
	}
	switch r {
	case '\\':
		r, sz = utf8.DecodeRune(str)
		if r == utf8.RuneError {
			panic(fmt.Sprintf("Rune error: %s", str))
		}
		switch r {
		case '"':
			return "\"", r, sz
		case 'n':
			return "n", r, sz
		case 'r':
			return "r", r, sz
		case 't':
			return "t", r, sz
		case '\\':
			return "\\", r, sz
		case '\'':
			return "'", r, sz
		}
	case '\t', ' ':
		return "space", r, sz
	case '\n':
		return "\\n", r, sz
	}
	return string(str[:sz]), r, sz
}

func runeToString(r rune) string {
	buf := make([]byte, utf8.RuneLen(r))
	utf8.EncodeRune(buf, r)
	return string(buf)
}

/*** TestSelect ***/

var testSelect = []func() bool{
	// slot.Alternate0R0
	func() bool {
		return r == '\'' ||
			r == '"' ||
			r == 'a' ||
			r == 'l' ||
			letter(r) ||
			r == 'n' ||
			r == 's' ||
			r == 'u'
	},

	// slot.Alternate0R1
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.Alternate1R0
	func() bool {
		return r == 'e'
	},

	// slot.Alternate1R1
	func() bool {
		return r == 'm'
	},

	// slot.Alternate1R2
	func() bool {
		return r == 'p'
	},

	// slot.Alternate1R3
	func() bool {
		return r == 't'
	},

	// slot.Alternate1R4
	func() bool {
		return r == 'y'
	},

	// slot.Alternate1R5
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.Alternates0R0
	func() bool {
		return r == '\'' ||
			r == '"' ||
			r == 'a' ||
			r == 'e' ||
			r == 'l' ||
			letter(r) ||
			r == 'n' ||
			r == 's' ||
			r == 'u'
	},

	// slot.Alternates0R1
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.Alternates1R0
	func() bool {
		return r == '\'' ||
			r == '"' ||
			r == 'a' ||
			r == 'e' ||
			r == 'l' ||
			letter(r) ||
			r == 'n' ||
			r == 's' ||
			r == 'u'
	},

	// slot.Alternates1R1
	func() bool {
		return anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.Alternates1R2
	func() bool {
		return r == '|'
	},

	// slot.Alternates1R3
	func() bool {
		return r == '\'' ||
			r == '"' ||
			r == 'a' ||
			anyof(r, "\n\r\t") ||
			r == 'e' ||
			r == 'l' ||
			letter(r) ||
			r == 'n' ||
			r == 's' ||
			space(r) ||
			r == 'u'
	},

	// slot.Alternates1R4
	func() bool {
		return r == '\'' ||
			r == '"' ||
			r == 'a' ||
			r == 'e' ||
			r == 'l' ||
			letter(r) ||
			r == 'n' ||
			r == 's' ||
			r == 'u'
	},

	// slot.Alternates1R5
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.CharLiteral0R0
	func() bool {
		return r == '\''
	},

	// slot.CharLiteral0R1
	func() bool {
		return r == '\\'
	},

	// slot.CharLiteral0R2
	func() bool {
		return anyof(r, "'\"\\\n\r\t")
	},

	// slot.CharLiteral0R3
	func() bool {
		return r == '\''
	},

	// slot.CharLiteral0R4
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.CharLiteral1R0
	func() bool {
		return r == '\''
	},

	// slot.CharLiteral1R1
	func() bool {
		return true
	},

	// slot.CharLiteral1R2
	func() bool {
		return r == '\''
	},

	// slot.CharLiteral1R3
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.EscapedChar0R0
	func() bool {
		return r == '"'
	},

	// slot.EscapedChar0R1
	func() bool {
		return r == '"' ||
			r == '\\' ||
			not(r, "\"\\")
	},

	// slot.EscapedChar1R0
	func() bool {
		return r == 'n'
	},

	// slot.EscapedChar1R1
	func() bool {
		return r == '"' ||
			r == '\\' ||
			not(r, "\"\\")
	},

	// slot.EscapedChar2R0
	func() bool {
		return r == 'r'
	},

	// slot.EscapedChar2R1
	func() bool {
		return r == '"' ||
			r == '\\' ||
			not(r, "\"\\")
	},

	// slot.EscapedChar3R0
	func() bool {
		return r == 't'
	},

	// slot.EscapedChar3R1
	func() bool {
		return r == '"' ||
			r == '\\' ||
			not(r, "\"\\")
	},

	// slot.EscapedChar4R0
	func() bool {
		return r == '\\'
	},

	// slot.EscapedChar4R1
	func() bool {
		return r == '"' ||
			r == '\\' ||
			not(r, "\"\\")
	},

	// slot.GoGLL0R0
	func() bool {
		return anyof(r, "\n\r\t") ||
			r == 'p' ||
			space(r)
	},

	// slot.GoGLL0R1
	func() bool {
		return r == 'p'
	},

	// slot.GoGLL0R2
	func() bool {
		return anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.GoGLL0R3
	func() bool {
		return r == '*' ||
			letter(r)
	},

	// slot.GoGLL0R4
	func() bool {
		return anyof(r, "\n\r\t") ||
			space(r) ||
			r == '$'
	},

	// slot.GoGLL0R5
	func() bool {
		return r == '$'
	},

	// slot.Head0R0
	func() bool {
		return r == '*'
	},

	// slot.Head0R1
	func() bool {
		return letter(r)
	},

	// slot.Head0R2
	func() bool {
		return r == ':' ||
			anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.Head1R0
	func() bool {
		return letter(r)
	},

	// slot.Head1R1
	func() bool {
		return r == ':' ||
			anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.NTChar0R0
	func() bool {
		return letter(r)
	},

	// slot.NTChar0R1
	func() bool {
		return r == ':' ||
			r == ';' ||
			anyof(r, "!#$%&*+-=@^_") ||
			anyof(r, "\n\r\t") ||
			letter(r) ||
			number(r) ||
			space(r) ||
			r == '|'
	},

	// slot.NTChar1R0
	func() bool {
		return number(r)
	},

	// slot.NTChar1R1
	func() bool {
		return r == ':' ||
			r == ';' ||
			anyof(r, "!#$%&*+-=@^_") ||
			anyof(r, "\n\r\t") ||
			letter(r) ||
			number(r) ||
			space(r) ||
			r == '|'
	},

	// slot.NTChar2R0
	func() bool {
		return anyof(r, "!#$%&*+-=@^_")
	},

	// slot.NTChar2R1
	func() bool {
		return r == ':' ||
			r == ';' ||
			anyof(r, "!#$%&*+-=@^_") ||
			anyof(r, "\n\r\t") ||
			letter(r) ||
			number(r) ||
			space(r) ||
			r == '|'
	},

	// slot.NTChars0R0
	func() bool {
		return anyof(r, "!#$%&*+-=@^_") ||
			letter(r) ||
			number(r)
	},

	// slot.NTChars0R1
	func() bool {
		return r == ':' ||
			r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.NTChars1R0
	func() bool {
		return anyof(r, "!#$%&*+-=@^_") ||
			letter(r) ||
			number(r)
	},

	// slot.NTChars1R1
	func() bool {
		return anyof(r, "!#$%&*+-=@^_") ||
			letter(r) ||
			number(r)
	},

	// slot.NTChars1R2
	func() bool {
		return r == ':' ||
			r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.NTID0R0
	func() bool {
		return letter(r)
	},

	// slot.NTID0R1
	func() bool {
		return r == ':' ||
			r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.NTID1R0
	func() bool {
		return letter(r)
	},

	// slot.NTID1R1
	func() bool {
		return anyof(r, "!#$%&*+-=@^_") ||
			letter(r) ||
			number(r)
	},

	// slot.NTID1R2
	func() bool {
		return r == ':' ||
			r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.NonTerminal0R0
	func() bool {
		return letter(r)
	},

	// slot.NonTerminal0R1
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.Package0R0
	func() bool {
		return r == 'p'
	},

	// slot.Package0R1
	func() bool {
		return r == 'a'
	},

	// slot.Package0R2
	func() bool {
		return r == 'c'
	},

	// slot.Package0R3
	func() bool {
		return r == 'k'
	},

	// slot.Package0R4
	func() bool {
		return r == 'a'
	},

	// slot.Package0R5
	func() bool {
		return r == 'g'
	},

	// slot.Package0R6
	func() bool {
		return r == 'e'
	},

	// slot.Package0R7
	func() bool {
		return anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.Package0R8
	func() bool {
		return r == '"'
	},

	// slot.Package0R9
	func() bool {
		return anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.Rule0R0
	func() bool {
		return r == '*' ||
			letter(r)
	},

	// slot.Rule0R1
	func() bool {
		return r == ':' ||
			anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.Rule0R2
	func() bool {
		return r == ':'
	},

	// slot.Rule0R3
	func() bool {
		return r == '\'' ||
			r == '"' ||
			r == 'a' ||
			anyof(r, "\n\r\t") ||
			r == 'e' ||
			r == 'l' ||
			letter(r) ||
			r == 'n' ||
			r == 's' ||
			space(r) ||
			r == 'u'
	},

	// slot.Rule0R4
	func() bool {
		return r == '\'' ||
			r == '"' ||
			r == 'a' ||
			r == 'e' ||
			r == 'l' ||
			letter(r) ||
			r == 'n' ||
			r == 's' ||
			r == 'u'
	},

	// slot.Rule0R5
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.Rule0R6
	func() bool {
		return r == ';'
	},

	// slot.Rule0R7
	func() bool {
		return r == '$' ||
			r == '*' ||
			anyof(r, "\n\r\t") ||
			letter(r) ||
			space(r)
	},

	// slot.Rules0R0
	func() bool {
		return r == '*' ||
			letter(r)
	},

	// slot.Rules0R1
	func() bool {
		return r == '$' ||
			anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.Rules1R0
	func() bool {
		return r == '*' ||
			letter(r)
	},

	// slot.Rules1R1
	func() bool {
		return r == '*' ||
			anyof(r, "\n\r\t") ||
			letter(r) ||
			space(r)
	},

	// slot.Rules1R2
	func() bool {
		return r == '*' ||
			letter(r)
	},

	// slot.Rules1R3
	func() bool {
		return r == '$' ||
			anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.Sep0R0
	func() bool {
		return anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.Sep0R1
	func() bool {
		return r == '$' ||
			r == '\'' ||
			r == '*' ||
			r == ':' ||
			r == ';' ||
			r == '"' ||
			r == 'a' ||
			r == 'e' ||
			r == 'l' ||
			letter(r) ||
			r == 'n' ||
			r == 'p' ||
			r == 's' ||
			r == 'u' ||
			r == '|'
	},

	// slot.Sep1R0
	func() bool {
		return anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.Sep1R1
	func() bool {
		return anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.Sep1R2
	func() bool {
		return r == '$' ||
			r == '\'' ||
			r == '*' ||
			r == ':' ||
			r == ';' ||
			r == '"' ||
			r == 'a' ||
			r == 'e' ||
			r == 'l' ||
			letter(r) ||
			r == 'n' ||
			r == 'p' ||
			r == 's' ||
			r == 'u' ||
			r == '|'
	},

	// slot.SepChar0R0
	func() bool {
		return space(r)
	},

	// slot.SepChar0R1
	func() bool {
		return r == '$' ||
			r == '\'' ||
			r == '*' ||
			r == ':' ||
			r == ';' ||
			r == '"' ||
			r == 'a' ||
			anyof(r, "\n\r\t") ||
			r == 'e' ||
			r == 'l' ||
			letter(r) ||
			r == 'n' ||
			r == 'p' ||
			r == 's' ||
			space(r) ||
			r == 'u' ||
			r == '|'
	},

	// slot.SepChar1R0
	func() bool {
		return anyof(r, "\n\r\t")
	},

	// slot.SepChar1R1
	func() bool {
		return r == '$' ||
			r == '\'' ||
			r == '*' ||
			r == ':' ||
			r == ';' ||
			r == '"' ||
			r == 'a' ||
			anyof(r, "\n\r\t") ||
			r == 'e' ||
			r == 'l' ||
			letter(r) ||
			r == 'n' ||
			r == 'p' ||
			r == 's' ||
			space(r) ||
			r == 'u' ||
			r == '|'
	},

	// slot.SepE0R0
	func() bool {
		return anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.SepE0R1
	func() bool {
		return r == '$' ||
			r == '\'' ||
			r == '*' ||
			r == ':' ||
			r == ';' ||
			r == '"' ||
			r == 'a' ||
			r == 'e' ||
			r == 'l' ||
			letter(r) ||
			r == 'n' ||
			r == 'p' ||
			r == 's' ||
			r == 'u' ||
			r == '|'
	},

	// slot.SepE1R0
	func() bool {
		return r == '$' ||
			r == '\'' ||
			r == '*' ||
			r == ':' ||
			r == ';' ||
			r == '"' ||
			r == 'a' ||
			r == 'e' ||
			r == 'l' ||
			letter(r) ||
			r == 'n' ||
			r == 'p' ||
			r == 's' ||
			r == 'u' ||
			r == '|'
	},

	// slot.String0R0
	func() bool {
		return r == '"'
	},

	// slot.String0R1
	func() bool {
		return r == '"' ||
			r == '\\' ||
			not(r, "\"\\")
	},

	// slot.String0R2
	func() bool {
		return r == '"'
	},

	// slot.String0R3
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.StringChars0R0
	func() bool {
		return not(r, "\"\\")
	},

	// slot.StringChars0R1
	func() bool {
		return r == '\\' ||
			not(r, "\"\\") ||
			r == '"'
	},

	// slot.StringChars0R2
	func() bool {
		return r == '"'
	},

	// slot.StringChars1R0
	func() bool {
		return r == '\\'
	},

	// slot.StringChars1R1
	func() bool {
		return r == '"' ||
			r == '\\' ||
			r == 'n' ||
			r == 'r' ||
			r == 't'
	},

	// slot.StringChars1R2
	func() bool {
		return r == '\\' ||
			not(r, "\"\\") ||
			r == '"'
	},

	// slot.StringChars1R3
	func() bool {
		return r == '"'
	},

	// slot.StringChars2R0
	func() bool {
		return r == '"'
	},

	// slot.Symbol0R0
	func() bool {
		return letter(r)
	},

	// slot.Symbol0R1
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.Symbol1R0
	func() bool {
		return r == '\'' ||
			r == '"' ||
			r == 'a' ||
			r == 'l' ||
			r == 'n' ||
			r == 's' ||
			r == 'u'
	},

	// slot.Symbol1R1
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.Symbols0R0
	func() bool {
		return r == '\'' ||
			r == '"' ||
			r == 'a' ||
			r == 'l' ||
			letter(r) ||
			r == 'n' ||
			r == 's' ||
			r == 'u'
	},

	// slot.Symbols0R1
	func() bool {
		return anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.Symbols0R2
	func() bool {
		return r == '\'' ||
			r == '"' ||
			r == 'a' ||
			r == 'l' ||
			letter(r) ||
			r == 'n' ||
			r == 's' ||
			r == 'u'
	},

	// slot.Symbols0R3
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.Symbols1R0
	func() bool {
		return r == '\'' ||
			r == '"' ||
			r == 'a' ||
			r == 'l' ||
			letter(r) ||
			r == 'n' ||
			r == 's' ||
			r == 'u'
	},

	// slot.Symbols1R1
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.Terminal0R0
	func() bool {
		return r == 'a'
	},

	// slot.Terminal0R1
	func() bool {
		return r == 'n'
	},

	// slot.Terminal0R2
	func() bool {
		return r == 'y'
	},

	// slot.Terminal0R3
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.Terminal1R0
	func() bool {
		return r == 'a'
	},

	// slot.Terminal1R1
	func() bool {
		return r == 'n'
	},

	// slot.Terminal1R2
	func() bool {
		return r == 'y'
	},

	// slot.Terminal1R3
	func() bool {
		return r == 'o'
	},

	// slot.Terminal1R4
	func() bool {
		return r == 'f'
	},

	// slot.Terminal1R5
	func() bool {
		return anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.Terminal1R6
	func() bool {
		return r == '"'
	},

	// slot.Terminal1R7
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.Terminal2R0
	func() bool {
		return r == 'l'
	},

	// slot.Terminal2R1
	func() bool {
		return r == 'e'
	},

	// slot.Terminal2R2
	func() bool {
		return r == 't'
	},

	// slot.Terminal2R3
	func() bool {
		return r == 't'
	},

	// slot.Terminal2R4
	func() bool {
		return r == 'e'
	},

	// slot.Terminal2R5
	func() bool {
		return r == 'r'
	},

	// slot.Terminal2R6
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.Terminal3R0
	func() bool {
		return r == 'n'
	},

	// slot.Terminal3R1
	func() bool {
		return r == 'u'
	},

	// slot.Terminal3R2
	func() bool {
		return r == 'm'
	},

	// slot.Terminal3R3
	func() bool {
		return r == 'b'
	},

	// slot.Terminal3R4
	func() bool {
		return r == 'e'
	},

	// slot.Terminal3R5
	func() bool {
		return r == 'r'
	},

	// slot.Terminal3R6
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.Terminal4R0
	func() bool {
		return r == 's'
	},

	// slot.Terminal4R1
	func() bool {
		return r == 'p'
	},

	// slot.Terminal4R2
	func() bool {
		return r == 'a'
	},

	// slot.Terminal4R3
	func() bool {
		return r == 'c'
	},

	// slot.Terminal4R4
	func() bool {
		return r == 'e'
	},

	// slot.Terminal4R5
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.Terminal5R0
	func() bool {
		return r == 'u'
	},

	// slot.Terminal5R1
	func() bool {
		return r == 'p'
	},

	// slot.Terminal5R2
	func() bool {
		return r == 'c'
	},

	// slot.Terminal5R3
	func() bool {
		return r == 'a'
	},

	// slot.Terminal5R4
	func() bool {
		return r == 's'
	},

	// slot.Terminal5R5
	func() bool {
		return r == 'e'
	},

	// slot.Terminal5R6
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.Terminal6R0
	func() bool {
		return r == 'l'
	},

	// slot.Terminal6R1
	func() bool {
		return r == 'o'
	},

	// slot.Terminal6R2
	func() bool {
		return r == 'w'
	},

	// slot.Terminal6R3
	func() bool {
		return r == 'c'
	},

	// slot.Terminal6R4
	func() bool {
		return r == 'a'
	},

	// slot.Terminal6R5
	func() bool {
		return r == 's'
	},

	// slot.Terminal6R6
	func() bool {
		return r == 'e'
	},

	// slot.Terminal6R7
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.Terminal7R0
	func() bool {
		return r == 'n'
	},

	// slot.Terminal7R1
	func() bool {
		return r == 'o'
	},

	// slot.Terminal7R2
	func() bool {
		return r == 't'
	},

	// slot.Terminal7R3
	func() bool {
		return anyof(r, "\n\r\t") ||
			space(r)
	},

	// slot.Terminal7R4
	func() bool {
		return r == '"'
	},

	// slot.Terminal7R5
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.Terminal8R0
	func() bool {
		return r == '\''
	},

	// slot.Terminal8R1
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},

	// slot.Terminal9R0
	func() bool {
		return r == '"'
	},

	// slot.Terminal9R1
	func() bool {
		return r == ';' ||
			anyof(r, "\n\r\t") ||
			space(r) ||
			r == '|'
	},
}

func followAlternate() bool {
	return r == ';' ||
		anyof(r, "\n\r\t") ||
		space(r) ||
		r == '|'
}
func followAlternates() bool {
	return r == ';' ||
		anyof(r, "\n\r\t") ||
		space(r)
}
func followCharLiteral() bool {
	return r == ';' ||
		anyof(r, "\n\r\t") ||
		space(r) ||
		r == '|'
}
func followEscapedChar() bool {
	return r == '"' ||
		r == '\\' ||
		not(r, "\"\\")
}
func followGoGLL() bool {
	return r == '$'
}
func followHead() bool {
	return r == ':' ||
		anyof(r, "\n\r\t") ||
		space(r)
}
func followNTChar() bool {
	return r == ':' ||
		r == ';' ||
		anyof(r, "!#$%&*+-=@^_") ||
		anyof(r, "\n\r\t") ||
		letter(r) ||
		number(r) ||
		space(r) ||
		r == '|'
}
func followNTChars() bool {
	return r == ':' ||
		r == ';' ||
		anyof(r, "\n\r\t") ||
		space(r) ||
		r == '|'
}
func followNTID() bool {
	return r == ':' ||
		r == ';' ||
		anyof(r, "\n\r\t") ||
		space(r) ||
		r == '|'
}
func followNonTerminal() bool {
	return r == ';' ||
		anyof(r, "\n\r\t") ||
		space(r) ||
		r == '|'
}
func followPackage() bool {
	return anyof(r, "\n\r\t") ||
		space(r)
}
func followRule() bool {
	return r == '$' ||
		r == '*' ||
		anyof(r, "\n\r\t") ||
		letter(r) ||
		space(r)
}
func followRules() bool {
	return r == '$' ||
		anyof(r, "\n\r\t") ||
		space(r)
}
func followSep() bool {
	return r == '$' ||
		r == '\'' ||
		r == '*' ||
		r == ':' ||
		r == ';' ||
		r == '"' ||
		r == 'a' ||
		r == 'e' ||
		r == 'l' ||
		letter(r) ||
		r == 'n' ||
		r == 'p' ||
		r == 's' ||
		r == 'u' ||
		r == '|'
}
func followSepChar() bool {
	return r == '$' ||
		r == '\'' ||
		r == '*' ||
		r == ':' ||
		r == ';' ||
		r == '"' ||
		r == 'a' ||
		anyof(r, "\n\r\t") ||
		r == 'e' ||
		r == 'l' ||
		letter(r) ||
		r == 'n' ||
		r == 'p' ||
		r == 's' ||
		space(r) ||
		r == 'u' ||
		r == '|'
}
func followSepE() bool {
	return r == '$' ||
		r == '\'' ||
		r == '*' ||
		r == ':' ||
		r == ';' ||
		r == '"' ||
		r == 'a' ||
		r == 'e' ||
		r == 'l' ||
		letter(r) ||
		r == 'n' ||
		r == 'p' ||
		r == 's' ||
		r == 'u' ||
		r == '|'
}
func followString() bool {
	return r == ';' ||
		anyof(r, "\n\r\t") ||
		space(r) ||
		r == '|'
}
func followStringChars() bool {
	return r == '"'
}
func followSymbol() bool {
	return r == ';' ||
		anyof(r, "\n\r\t") ||
		space(r) ||
		r == '|'
}
func followSymbols() bool {
	return r == ';' ||
		anyof(r, "\n\r\t") ||
		space(r) ||
		r == '|'
}
func followTerminal() bool {
	return r == ';' ||
		anyof(r, "\n\r\t") ||
		space(r) ||
		r == '|'
}

/*** Unicode functions ***/

func any(r rune) bool {
	return true
}

func anyof(r rune, set string) bool {
	return strings.ContainsRune(set, r)
}

func letter(r rune) bool {
	return unicode.IsLetter(r)
}

func number(r rune) bool {
	return unicode.IsNumber(r)
}

func upcase(r rune) bool {
	return unicode.IsUpper(r)
}

func lowcase(r rune) bool {
	return unicode.IsLower(r)
}

func not(r rune, set string) bool {
	bs := []byte(set)
	for i := 0; i < len(set); {
		r1, sz := utf8.DecodeRune(bs[i:])
		if r1 == utf8.RuneError {
			panic(fmt.Sprintf("Rune error: %s", set))
		}
		if r1 == r {
			return false
		}
		i += sz
	}
	return true
}

func space(r rune) bool {
	return unicode.IsSpace(r)
}

/*** Errors ***/

type ParseError struct {
	Slot         slot.Label
	InputPos     int
	Char         string
	Line, Column int
}

func (pe *ParseError) String() string {
	return fmt.Sprintf("Parse Error: %s cI=%d I[cI]=%s at line %d col %d",
		pe.Slot, pe.InputPos, pe.Char, pe.Line, pe.Column)
}

func parseError(slot slot.Label, I int) {
	pe := &ParseError{Slot: slot, InputPos: I, Char: nextI}
	parseErrors = append(parseErrors, pe)
}

func sortParseErrors(I []byte) {
	sort.Slice(parseErrors,
		func(i, j int) bool {
			return parseErrors[j].InputPos < parseErrors[i].InputPos
		})
	for _, pe := range parseErrors {
		pe.Line, pe.Column = GetLineColumn(pe.InputPos)
	}
}

func GetLineColumn(cI int) (line, col int) {
	line, col = 1, 1
	for j := 0; j < cI; {
		_, r, sz := decodeRune(input[j:])
		switch r {
		case '\n':
			line++
			col = 1
		case '\t':
			col += 4
		default:
			col++
		}
		j += sz
	}
	return
}

func parseErrorError(err error) {
	fmt.Printf("Error: %s\n", err)
	os.Exit(1)
}
