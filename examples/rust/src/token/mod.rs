
//! Module token is generated by GoGLL. Do not edit

extern crate lazy_static;

use std::rc::Rc;
use std::fmt;
use lazy_static::lazy_static;
use std::collections::HashMap;

/// Token is returned by the lexer for every scanned lexical token
pub struct Token {
	pub typ: Type,
	pub lext: usize, 
	pub rext: usize,
	input: Rc<Vec<char>>,
}

#[derive(PartialEq, Eq, Hash, Clone, Copy)]
pub enum Type {	
	Error, // "Error"
	EOF, // "EOF"
	Type0, // "("
	Type1, // ")"
	Type2, // "."
	Type3, // ":"
	Type4, // ";"
	Type5, // "<"
	Type6, // ">"
	Type7, // "["
	Type8, // "]"
	Type9, // "any"
	Type10, // "char_lit"
	Type11, // "empty"
	Type12, // "letter"
	Type13, // "lowcase"
	Type14, // "not"
	Type15, // "nt"
	Type16, // "number"
	Type17, // "package"
	Type18, // "string_lit"
	Type19, // "tokid"
	Type20, // "upcase"
	Type21, // "{"
	Type22, // "|"
	Type23, // "}"
}

/**
New returns a new token.  
lext is the left extent and rext the right extent of the token in the input.  
input is the input slice scanned by the lexer.
*/
pub fn new<'a>(t: Type, lext: usize, rext: usize, input: &Rc<Vec<char>>) -> Rc<Token> {
	Rc::new(Token{
		typ:   t,
		lext:  lext,
		rext:  rext,
		input: input.clone(),
	})
}

impl Token {
	/// get_line_column returns the (line, column) of the left extent of the token
	pub fn get_line_column(&self) -> (usize, usize) {
		let mut line = 1;
		let mut col = 1;
		let mut j = 0;
		while j < self.lext {
			match self.input[j] {
			'\n' => {
				line += 1;
				col = 1
			},
			'\t' => col += 4,
			_ => col += 1
			}
			j += 1
		}
		(line, col)
	}
	
	/// get_input returns the input from which t was parsed.
	// pub fn get_input(&self) -> Rc<Vec<char>> {
	// 	Rc::clone(&self.input)
	// }
	
	/// literal returns the literal runes of t scanned by the lexer
	pub fn literal(&self) -> Vec<char> {
		self.input[self.lext..self.rext].to_vec()
	}
	
}

impl <'a>fmt::Display for Token {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		let (ln, col) = self.get_line_column();
		write!(f, "({}, ({},{}) {})", 
			self.typ, ln, col, self.literal().iter().collect::<String>())
	}

}

impl <'a>Type {
	/// id returns the token type ID of token Type t
	#[allow(dead_code)]
	pub fn id(&self) -> &'a str {
		TYPE_TO_STRING[self]
	}
	
}

impl <'a>fmt::Display for Type {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		write!(f, "{}", TYPE_TO_STRING[self])
	}

}

lazy_static! {
    static ref TYPE_TO_STRING: HashMap<Type, &'static str> = {
        let mut m = HashMap::new(); 
		m.insert(Type::Error, "Error");
		m.insert(Type::EOF, "EOF");
		m.insert(Type::Type0, "(");
		m.insert(Type::Type1, ")");
		m.insert(Type::Type2, ".");
		m.insert(Type::Type3, ":");
		m.insert(Type::Type4, ";");
		m.insert(Type::Type5, "<");
		m.insert(Type::Type6, ">");
		m.insert(Type::Type7, "[");
		m.insert(Type::Type8, "]");
		m.insert(Type::Type9, "any");
		m.insert(Type::Type10, "char_lit");
		m.insert(Type::Type11, "empty");
		m.insert(Type::Type12, "letter");
		m.insert(Type::Type13, "lowcase");
		m.insert(Type::Type14, "not");
		m.insert(Type::Type15, "nt");
		m.insert(Type::Type16, "number");
		m.insert(Type::Type17, "package");
		m.insert(Type::Type18, "string_lit");
		m.insert(Type::Type19, "tokid");
		m.insert(Type::Type20, "upcase");
		m.insert(Type::Type21, "{");
		m.insert(Type::Type22, "|");
		m.insert(Type::Type23, "}");
        m
    };
}

lazy_static! {
	static ref STRING_TO_TYPE: HashMap<&'static str, Type> = {
		let mut m = HashMap::new(); 
		m.insert("Error", Type::Error); 
		m.insert("EOF", Type::EOF); 
		m.insert("Type0", Type::Type0); 
		m.insert("Type1", Type::Type1); 
		m.insert("Type2", Type::Type2); 
		m.insert("Type3", Type::Type3); 
		m.insert("Type4", Type::Type4); 
		m.insert("Type5", Type::Type5); 
		m.insert("Type6", Type::Type6); 
		m.insert("Type7", Type::Type7); 
		m.insert("Type8", Type::Type8); 
		m.insert("Type9", Type::Type9); 
		m.insert("Type10", Type::Type10); 
		m.insert("Type11", Type::Type11); 
		m.insert("Type12", Type::Type12); 
		m.insert("Type13", Type::Type13); 
		m.insert("Type14", Type::Type14); 
		m.insert("Type15", Type::Type15); 
		m.insert("Type16", Type::Type16); 
		m.insert("Type17", Type::Type17); 
		m.insert("Type18", Type::Type18); 
		m.insert("Type19", Type::Type19); 
		m.insert("Type20", Type::Type20); 
		m.insert("Type21", Type::Type21); 
		m.insert("Type22", Type::Type22); 
		m.insert("Type23", Type::Type23); 
		m
	};
}
