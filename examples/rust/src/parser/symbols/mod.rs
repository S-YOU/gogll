// Module symbols is generated by gogll. Do not edit.

use std::fmt;

#[allow(dead_code)]
#[derive(Hash, Eq, PartialEq)]
pub enum Symbol {
    NT(NT),
    T(T)
}

// NT is the type of non-terminals symbols
#[allow(dead_code)]
#[derive(Hash, Eq, PartialEq, Clone, Copy, Debug)]
pub enum NT { 
    GoGLL,
    LexAlternates,
    LexBracket,
    LexGroup,
    LexOneOrMore,
    LexOptional,
    LexRule,
    LexSymbol,
    LexZeroOrMore,
    Package,
    RegExp,
    Rule,
    Rules,
    SyntaxAlternate,
    SyntaxAlternates,
    SyntaxRule,
    SyntaxSymbol,
    SyntaxSymbols,
    UnicodeClass,
}

// T is the type of terminals symbols
#[allow(dead_code)]
#[derive(Hash, Eq, PartialEq)]
pub enum T { 
    T0, // ( 
    T1, // ) 
    T2, // . 
    T3, // : 
    T4, // ; 
    T5, // < 
    T6, // > 
    T7, // [ 
    T8, // ] 
    T9, // any 
    T10, // char_lit 
    T11, // empty 
    T12, // letter 
    T13, // lowcase 
    T14, // not 
    T15, // nt 
    T16, // number 
    T17, // package 
    T18, // string_lit 
    T19, // tokid 
    T20, // upcase 
    T21, // { 
    T22, // | 
    T23, // } 	
}

/// Format a &Vec<Symbol> into a String
#[allow(dead_code)]
pub fn to_string(symbols: &Vec<Symbol>) -> String {
    let mut st: String = "".to_string();
    for sym in symbols.iter() {
        st.push_str(&format!("{} ",sym));
    }
    st
}

impl Symbol {
    #[allow(dead_code)]
    pub fn is_nt(&self) -> bool {
        match self {
            Symbol::NT(_) => return true,
            Symbol::T(_) => return false,
        }
    }
}

impl fmt::Display for NT {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {  
            NT::GoGLL => write!(f, "GoGLL"), 
            NT::LexAlternates => write!(f, "LexAlternates"), 
            NT::LexBracket => write!(f, "LexBracket"), 
            NT::LexGroup => write!(f, "LexGroup"), 
            NT::LexOneOrMore => write!(f, "LexOneOrMore"), 
            NT::LexOptional => write!(f, "LexOptional"), 
            NT::LexRule => write!(f, "LexRule"), 
            NT::LexSymbol => write!(f, "LexSymbol"), 
            NT::LexZeroOrMore => write!(f, "LexZeroOrMore"), 
            NT::Package => write!(f, "Package"), 
            NT::RegExp => write!(f, "RegExp"), 
            NT::Rule => write!(f, "Rule"), 
            NT::Rules => write!(f, "Rules"), 
            NT::SyntaxAlternate => write!(f, "SyntaxAlternate"), 
            NT::SyntaxAlternates => write!(f, "SyntaxAlternates"), 
            NT::SyntaxRule => write!(f, "SyntaxRule"), 
            NT::SyntaxSymbol => write!(f, "SyntaxSymbol"), 
            NT::SyntaxSymbols => write!(f, "SyntaxSymbols"), 
            NT::UnicodeClass => write!(f, "UnicodeClass"),
        }
    }
}

impl fmt::Display for T {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {  
            T::T0 => write!(f, "("), 
            T::T1 => write!(f, ")"), 
            T::T2 => write!(f, "."), 
            T::T3 => write!(f, ":"), 
            T::T4 => write!(f, ";"), 
            T::T5 => write!(f, "<"), 
            T::T6 => write!(f, ">"), 
            T::T7 => write!(f, "["), 
            T::T8 => write!(f, "]"), 
            T::T9 => write!(f, "any"), 
            T::T10 => write!(f, "char_lit"), 
            T::T11 => write!(f, "empty"), 
            T::T12 => write!(f, "letter"), 
            T::T13 => write!(f, "lowcase"), 
            T::T14 => write!(f, "not"), 
            T::T15 => write!(f, "nt"), 
            T::T16 => write!(f, "number"), 
            T::T17 => write!(f, "package"), 
            T::T18 => write!(f, "string_lit"), 
            T::T19 => write!(f, "tokid"), 
            T::T20 => write!(f, "upcase"), 
            T::T21 => write!(f, "{{"), 
            T::T22 => write!(f, "|"), 
            T::T23 => write!(f, "}}"),
        }
    }
}

impl fmt::Display for Symbol {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self { 
            Symbol::NT(nt) => write!(f, "{}", nt),
            Symbol::T(t) => write!(f, "{}", t)
        }
    }
}

// ToDo: Delete
// impl fmt::Display for NT {
//     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
//         match self {  
//             NT::GoGLL => write!(f, "GoGLL"), 
//             NT::LexAlternates => write!(f, "LexAlternates"), 
//             NT::LexBracket => write!(f, "LexBracket"), 
//             NT::LexGroup => write!(f, "LexGroup"), 
//             NT::LexOneOrMore => write!(f, "LexOneOrMore"), 
//             NT::LexOptional => write!(f, "LexOptional"), 
//             NT::LexRule => write!(f, "LexRule"), 
//             NT::LexSymbol => write!(f, "LexSymbol"), 
//             NT::LexZeroOrMore => write!(f, "LexZeroOrMore"), 
//             NT::Package => write!(f, "Package"), 
//             NT::RegExp => write!(f, "RegExp"), 
//             NT::Rule => write!(f, "Rule"), 
//             NT::Rules => write!(f, "Rules"), 
//             NT::SyntaxAlternate => write!(f, "SyntaxAlternate"), 
//             NT::SyntaxAlternates => write!(f, "SyntaxAlternates"), 
//             NT::SyntaxRule => write!(f, "SyntaxRule"), 
//             NT::SyntaxSymbol => write!(f, "SyntaxSymbol"), 
//             NT::SyntaxSymbols => write!(f, "SyntaxSymbols"), 
//             NT::UnicodeClass => write!(f, "UnicodeClass"),
//         }
//     }
// }

// impl fmt::Display for T {
//     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
//         match self {  
//             T::T0 => write!(f, "("), 
//             T::T1 => write!(f, ")"), 
//             T::T2 => write!(f, "."), 
//             T::T3 => write!(f, ":"), 
//             T::T4 => write!(f, ";"), 
//             T::T5 => write!(f, "<"), 
//             T::T6 => write!(f, ">"), 
//             T::T7 => write!(f, "["), 
//             T::T8 => write!(f, "]"), 
//             T::T9 => write!(f, "any"), 
//             T::T10 => write!(f, "char_lit"), 
//             T::T11 => write!(f, "empty"), 
//             T::T12 => write!(f, "letter"), 
//             T::T13 => write!(f, "lowcase"), 
//             T::T14 => write!(f, "not"), 
//             T::T15 => write!(f, "nt"), 
//             T::T16 => write!(f, "number"), 
//             T::T17 => write!(f, "package"), 
//             T::T18 => write!(f, "string_lit"), 
//             T::T19 => write!(f, "tokid"), 
//             T::T20 => write!(f, "upcase"), 
//             T::T21 => write!(f, "{{"), 
//             T::T22 => write!(f, "|"), 
//             T::T23 => write!(f, "}}"),
//         }
//     }
// }

// impl fmt::Display for Symbol {
//     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
//         match self { 
//             Symbol::NT(nt) => write!(f, "Symbol::NT({})", nt),
//             Symbol::T(t) => write!(f, "Symbol::T({})", t)
//         }
//     }
// }
