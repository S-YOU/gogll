//! Module parser is generated by GoGLL. Do not edit.

extern crate lazy_static;

pub mod bsr;
mod slot;
mod symbols;

use crate::lexer;
use crate::token;
use slot::{Label};
use symbols::{NT,Symbol};

use lazy_static::lazy_static;
use std::collections::{HashMap, HashSet};
use std::fmt;
use std::rc::Rc;

struct Parser {
	c_i: usize,

	r: Vec<Rc<Descriptor>>,
	u: Vec<Rc<Descriptor>>,

	popped:    HashSet<Box<PoppedNode>>,
	crf:       HashMap<ClusterNode, HashSet<CRFNode>>,
	crf_nodes: HashSet<CRFNode>,

	lex:    Rc<lexer::Lexer>,
	errors: Vec<Box<ParseError>>,

	bsr_set: Box<bsr::Set>,
}

// ToDo: delete
// struct Descriptors {
// 	set: Vec<Box<Descriptor>>,
// }

#[derive(Hash,Eq,PartialEq,Debug)]
struct Descriptor {
	l: Label,
	k: usize,
	i: usize,
}

/**
Error is returned by Parse at every point at which the parser fails to parse
a grammar production. For non-LL-1 grammars there will be an error for each
alternate attempted by the parser.

The errors are sorted in descending order of input position (index of token in
the stream of tokens).

Normally the error of interest is the one that has parsed the largest number of
tokens.
*/
pub struct Error {
	/// Index of token that caused the error.
	pub c_i: usize,

	/// Grammar slot at which the error occured.
	pub slot: Label,

	/// The token at which the error occurred.
	pub token: Rc<token::Token>,

	/// The tokens expected at the point where the error occurred
    pub expected: Box<HashSet<token::Type>>,
    
    /// The line in the input where the error occurred
    pub line: usize,

    /// The column on the line where the error occurred
    pub column: usize,
}

// ParseErrors are generated during the parse. After a failed parse they 
// are translated to Errors, which are returned to the user.
struct ParseError {
    c_i: usize,
    slot: Label,
    token: Rc<token::Token>,
    expected: Expected,
}

// Expected indicates whether to use the First or Follow set for the exported error.
enum Expected {
    First,
    Follow(NT)
}

#[derive(Hash, Eq, PartialEq, Debug, Clone, Copy)]
struct PoppedNode {
	x: NT,
    k: usize,
    j: usize,
}

#[derive(Hash, Eq, PartialEq, Debug, Clone, Copy)]
struct ClusterNode {
	x: symbols::NT,
	k: usize,
}

// Call return forest node
#[derive(Hash, Eq, PartialEq, Debug, Clone, Copy)]
struct CRFNode {
	l: Label,
	i: usize,
}

/// Parse returns the BSR set containing the parse forest.
/// If the parse was successfull the length of Vec\<Box\<Error\>\> = 0.
#[allow(dead_code)]
pub fn parse(l: Rc<lexer::Lexer>) -> (Box<bsr::Set>, Vec<Box<Error>>) {
    let mut p = Parser::new(l.clone());
    p.parse();
    if !p.bsr_set.contain(&NT::GoGLL, 0, l.tokens.len()-1) {
        let errors = p.export_errors();
        (p.bsr_set, errors)
    } else {
        (p.bsr_set, vec![])
    }
}

impl Parser {
    fn new(l: Rc<lexer::Lexer>) -> Box<Parser> {
        let mut p = Box::new(Parser{
            c_i:         0,
            lex:         l.clone(),
            r:           Vec::with_capacity(1024),
            u:           Vec::with_capacity(1024),
            popped:      HashSet::with_capacity(1024),
            crf:         HashMap::with_capacity(1024),
            crf_nodes:   HashSet::with_capacity(1024),
            bsr_set:     bsr::Set::new(NT::GoGLL, l.clone()),
            errors:      Vec::with_capacity(1024),
        });
        p.crf.insert(ClusterNode::new(NT::GoGLL, 0), HashSet::with_capacity(128));
        p
    }

    fn parse(&mut self) {
        // let mut c_u = 0;
        self.nt_add(NT::GoGLL, 0);
        // let mut slotNo = 0;
        while self.r.len() > 0 {
            let (l, c_u, c_i) = self.r_remove();
            self.c_i = c_i;

            // println!("{no}:{l} i {i} u {u} tok {t}", 
            //     no=slotNo, l=l, i=c_i, u=c_u, t=self.lex.tokens[c_i]);
            // slotNo += 1;

            // for d in self.r.iter() {
            //     println!("  {}", d);
            // }

            (|| {
                match l { 
                    // GoGLL : ∙Package Rules 
                    Label::GoGLL0R0 => { 
                        self.call(Label::GoGLL0R1, c_u, self.c_i);
                    },
                    // GoGLL : Package ∙Rules 
                    Label::GoGLL0R1 => {
                        if !self.test_select(Label::GoGLL0R1){ 
                            self.error_first(Label::GoGLL0R1, self.c_i);
                            return; 
                        }
                        self.call(Label::GoGLL0R2, c_u, self.c_i);
                    },
                    // GoGLL : Package Rules ∙
                    Label::GoGLL0R2 => {
                        if self.follow(NT::GoGLL) {
                            self.rtn(NT::GoGLL, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::GoGLL0R0, self.c_i, NT::GoGLL)
                        }
                    }, 
                    // LexAlternates : ∙RegExp 
                    Label::LexAlternates0R0 => { 
                        self.call(Label::LexAlternates0R1, c_u, self.c_i);
                    },
                    // LexAlternates : RegExp ∙
                    Label::LexAlternates0R1 => {
                        if self.follow(NT::LexAlternates) {
                            self.rtn(NT::LexAlternates, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::LexAlternates0R0, self.c_i, NT::LexAlternates)
                        }
                    }, 
                    // LexAlternates : ∙RegExp | LexAlternates 
                    Label::LexAlternates1R0 => { 
                        self.call(Label::LexAlternates1R1, c_u, self.c_i);
                    },
                    // LexAlternates : RegExp ∙| LexAlternates 
                    Label::LexAlternates1R1 => {
                        if !self.test_select(Label::LexAlternates1R1){ 
                            self.error_first(Label::LexAlternates1R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::LexAlternates1R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::LexAlternates1R2){ 
                            self.error_first(Label::LexAlternates1R2, self.c_i);
                            return; 
                        }
                        self.call(Label::LexAlternates1R3, c_u, self.c_i);
                    },
                    // LexAlternates : RegExp | LexAlternates ∙
                    Label::LexAlternates1R3 => {
                        if self.follow(NT::LexAlternates) {
                            self.rtn(NT::LexAlternates, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::LexAlternates1R0, self.c_i, NT::LexAlternates)
                        }
                    }, 
                    // LexBracket : ∙LexGroup 
                    Label::LexBracket0R0 => { 
                        self.call(Label::LexBracket0R1, c_u, self.c_i);
                    },
                    // LexBracket : LexGroup ∙
                    Label::LexBracket0R1 => {
                        if self.follow(NT::LexBracket) {
                            self.rtn(NT::LexBracket, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::LexBracket0R0, self.c_i, NT::LexBracket)
                        }
                    }, 
                    // LexBracket : ∙LexOptional 
                    Label::LexBracket1R0 => { 
                        self.call(Label::LexBracket1R1, c_u, self.c_i);
                    },
                    // LexBracket : LexOptional ∙
                    Label::LexBracket1R1 => {
                        if self.follow(NT::LexBracket) {
                            self.rtn(NT::LexBracket, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::LexBracket1R0, self.c_i, NT::LexBracket)
                        }
                    }, 
                    // LexBracket : ∙LexZeroOrMore 
                    Label::LexBracket2R0 => { 
                        self.call(Label::LexBracket2R1, c_u, self.c_i);
                    },
                    // LexBracket : LexZeroOrMore ∙
                    Label::LexBracket2R1 => {
                        if self.follow(NT::LexBracket) {
                            self.rtn(NT::LexBracket, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::LexBracket2R0, self.c_i, NT::LexBracket)
                        }
                    }, 
                    // LexBracket : ∙LexOneOrMore 
                    Label::LexBracket3R0 => { 
                        self.call(Label::LexBracket3R1, c_u, self.c_i);
                    },
                    // LexBracket : LexOneOrMore ∙
                    Label::LexBracket3R1 => {
                        if self.follow(NT::LexBracket) {
                            self.rtn(NT::LexBracket, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::LexBracket3R0, self.c_i, NT::LexBracket)
                        }
                    }, 
                    // LexGroup : ∙( LexAlternates ) 
                    Label::LexGroup0R0 => { 
                        self.bsr_set.add(Label::LexGroup0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::LexGroup0R1){ 
                            self.error_first(Label::LexGroup0R1, self.c_i);
                            return; 
                        }
                        self.call(Label::LexGroup0R2, c_u, self.c_i);
                    },
                    // LexGroup : ( LexAlternates ∙) 
                    Label::LexGroup0R2 => {
                        if !self.test_select(Label::LexGroup0R2){ 
                            self.error_first(Label::LexGroup0R2, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::LexGroup0R3, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::LexGroup) {
                            self.rtn(NT::LexGroup, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::LexGroup0R0, self.c_i, NT::LexGroup)
                        }
                    }, 
                    // LexOneOrMore : ∙< LexAlternates > 
                    Label::LexOneOrMore0R0 => { 
                        self.bsr_set.add(Label::LexOneOrMore0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::LexOneOrMore0R1){ 
                            self.error_first(Label::LexOneOrMore0R1, self.c_i);
                            return; 
                        }
                        self.call(Label::LexOneOrMore0R2, c_u, self.c_i);
                    },
                    // LexOneOrMore : < LexAlternates ∙> 
                    Label::LexOneOrMore0R2 => {
                        if !self.test_select(Label::LexOneOrMore0R2){ 
                            self.error_first(Label::LexOneOrMore0R2, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::LexOneOrMore0R3, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::LexOneOrMore) {
                            self.rtn(NT::LexOneOrMore, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::LexOneOrMore0R0, self.c_i, NT::LexOneOrMore)
                        }
                    }, 
                    // LexOptional : ∙[ LexAlternates ] 
                    Label::LexOptional0R0 => { 
                        self.bsr_set.add(Label::LexOptional0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::LexOptional0R1){ 
                            self.error_first(Label::LexOptional0R1, self.c_i);
                            return; 
                        }
                        self.call(Label::LexOptional0R2, c_u, self.c_i);
                    },
                    // LexOptional : [ LexAlternates ∙] 
                    Label::LexOptional0R2 => {
                        if !self.test_select(Label::LexOptional0R2){ 
                            self.error_first(Label::LexOptional0R2, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::LexOptional0R3, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::LexOptional) {
                            self.rtn(NT::LexOptional, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::LexOptional0R0, self.c_i, NT::LexOptional)
                        }
                    }, 
                    // LexRule : ∙tokid : RegExp ; 
                    Label::LexRule0R0 => { 
                        self.bsr_set.add(Label::LexRule0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::LexRule0R1){ 
                            self.error_first(Label::LexRule0R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::LexRule0R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::LexRule0R2){ 
                            self.error_first(Label::LexRule0R2, self.c_i);
                            return; 
                        }
                        self.call(Label::LexRule0R3, c_u, self.c_i);
                    },
                    // LexRule : tokid : RegExp ∙; 
                    Label::LexRule0R3 => {
                        if !self.test_select(Label::LexRule0R3){ 
                            self.error_first(Label::LexRule0R3, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::LexRule0R4, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::LexRule) {
                            self.rtn(NT::LexRule, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::LexRule0R0, self.c_i, NT::LexRule)
                        }
                    }, 
                    // LexSymbol : ∙. 
                    Label::LexSymbol0R0 => { 
                        self.bsr_set.add(Label::LexSymbol0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::LexSymbol) {
                            self.rtn(NT::LexSymbol, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::LexSymbol0R0, self.c_i, NT::LexSymbol)
                        }
                    }, 
                    // LexSymbol : ∙any string_lit 
                    Label::LexSymbol1R0 => { 
                        self.bsr_set.add(Label::LexSymbol1R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::LexSymbol1R1){ 
                            self.error_first(Label::LexSymbol1R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::LexSymbol1R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::LexSymbol) {
                            self.rtn(NT::LexSymbol, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::LexSymbol1R0, self.c_i, NT::LexSymbol)
                        }
                    }, 
                    // LexSymbol : ∙char_lit 
                    Label::LexSymbol2R0 => { 
                        self.bsr_set.add(Label::LexSymbol2R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::LexSymbol) {
                            self.rtn(NT::LexSymbol, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::LexSymbol2R0, self.c_i, NT::LexSymbol)
                        }
                    }, 
                    // LexSymbol : ∙LexBracket 
                    Label::LexSymbol3R0 => { 
                        self.call(Label::LexSymbol3R1, c_u, self.c_i);
                    },
                    // LexSymbol : LexBracket ∙
                    Label::LexSymbol3R1 => {
                        if self.follow(NT::LexSymbol) {
                            self.rtn(NT::LexSymbol, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::LexSymbol3R0, self.c_i, NT::LexSymbol)
                        }
                    }, 
                    // LexSymbol : ∙not string_lit 
                    Label::LexSymbol4R0 => { 
                        self.bsr_set.add(Label::LexSymbol4R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::LexSymbol4R1){ 
                            self.error_first(Label::LexSymbol4R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::LexSymbol4R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::LexSymbol) {
                            self.rtn(NT::LexSymbol, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::LexSymbol4R0, self.c_i, NT::LexSymbol)
                        }
                    }, 
                    // LexSymbol : ∙UnicodeClass 
                    Label::LexSymbol5R0 => { 
                        self.call(Label::LexSymbol5R1, c_u, self.c_i);
                    },
                    // LexSymbol : UnicodeClass ∙
                    Label::LexSymbol5R1 => {
                        if self.follow(NT::LexSymbol) {
                            self.rtn(NT::LexSymbol, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::LexSymbol5R0, self.c_i, NT::LexSymbol)
                        }
                    }, 
                    // LexZeroOrMore : ∙{ LexAlternates } 
                    Label::LexZeroOrMore0R0 => { 
                        self.bsr_set.add(Label::LexZeroOrMore0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::LexZeroOrMore0R1){ 
                            self.error_first(Label::LexZeroOrMore0R1, self.c_i);
                            return; 
                        }
                        self.call(Label::LexZeroOrMore0R2, c_u, self.c_i);
                    },
                    // LexZeroOrMore : { LexAlternates ∙} 
                    Label::LexZeroOrMore0R2 => {
                        if !self.test_select(Label::LexZeroOrMore0R2){ 
                            self.error_first(Label::LexZeroOrMore0R2, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::LexZeroOrMore0R3, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::LexZeroOrMore) {
                            self.rtn(NT::LexZeroOrMore, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::LexZeroOrMore0R0, self.c_i, NT::LexZeroOrMore)
                        }
                    }, 
                    // Package : ∙package string_lit 
                    Label::Package0R0 => { 
                        self.bsr_set.add(Label::Package0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Package0R1){ 
                            self.error_first(Label::Package0R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Package0R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::Package) {
                            self.rtn(NT::Package, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Package0R0, self.c_i, NT::Package)
                        }
                    }, 
                    // RegExp : ∙LexSymbol 
                    Label::RegExp0R0 => { 
                        self.call(Label::RegExp0R1, c_u, self.c_i);
                    },
                    // RegExp : LexSymbol ∙
                    Label::RegExp0R1 => {
                        if self.follow(NT::RegExp) {
                            self.rtn(NT::RegExp, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::RegExp0R0, self.c_i, NT::RegExp)
                        }
                    }, 
                    // RegExp : ∙LexSymbol RegExp 
                    Label::RegExp1R0 => { 
                        self.call(Label::RegExp1R1, c_u, self.c_i);
                    },
                    // RegExp : LexSymbol ∙RegExp 
                    Label::RegExp1R1 => {
                        if !self.test_select(Label::RegExp1R1){ 
                            self.error_first(Label::RegExp1R1, self.c_i);
                            return; 
                        }
                        self.call(Label::RegExp1R2, c_u, self.c_i);
                    },
                    // RegExp : LexSymbol RegExp ∙
                    Label::RegExp1R2 => {
                        if self.follow(NT::RegExp) {
                            self.rtn(NT::RegExp, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::RegExp1R0, self.c_i, NT::RegExp)
                        }
                    }, 
                    // Rule : ∙LexRule 
                    Label::Rule0R0 => { 
                        self.call(Label::Rule0R1, c_u, self.c_i);
                    },
                    // Rule : LexRule ∙
                    Label::Rule0R1 => {
                        if self.follow(NT::Rule) {
                            self.rtn(NT::Rule, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Rule0R0, self.c_i, NT::Rule)
                        }
                    }, 
                    // Rule : ∙SyntaxRule 
                    Label::Rule1R0 => { 
                        self.call(Label::Rule1R1, c_u, self.c_i);
                    },
                    // Rule : SyntaxRule ∙
                    Label::Rule1R1 => {
                        if self.follow(NT::Rule) {
                            self.rtn(NT::Rule, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Rule1R0, self.c_i, NT::Rule)
                        }
                    }, 
                    // Rules : ∙Rule 
                    Label::Rules0R0 => { 
                        self.call(Label::Rules0R1, c_u, self.c_i);
                    },
                    // Rules : Rule ∙
                    Label::Rules0R1 => {
                        if self.follow(NT::Rules) {
                            self.rtn(NT::Rules, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Rules0R0, self.c_i, NT::Rules)
                        }
                    }, 
                    // Rules : ∙Rule Rules 
                    Label::Rules1R0 => { 
                        self.call(Label::Rules1R1, c_u, self.c_i);
                    },
                    // Rules : Rule ∙Rules 
                    Label::Rules1R1 => {
                        if !self.test_select(Label::Rules1R1){ 
                            self.error_first(Label::Rules1R1, self.c_i);
                            return; 
                        }
                        self.call(Label::Rules1R2, c_u, self.c_i);
                    },
                    // Rules : Rule Rules ∙
                    Label::Rules1R2 => {
                        if self.follow(NT::Rules) {
                            self.rtn(NT::Rules, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Rules1R0, self.c_i, NT::Rules)
                        }
                    }, 
                    // SyntaxAlternate : ∙SyntaxSymbols 
                    Label::SyntaxAlternate0R0 => { 
                        self.call(Label::SyntaxAlternate0R1, c_u, self.c_i);
                    },
                    // SyntaxAlternate : SyntaxSymbols ∙
                    Label::SyntaxAlternate0R1 => {
                        if self.follow(NT::SyntaxAlternate) {
                            self.rtn(NT::SyntaxAlternate, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::SyntaxAlternate0R0, self.c_i, NT::SyntaxAlternate)
                        }
                    }, 
                    // SyntaxAlternate : ∙empty 
                    Label::SyntaxAlternate1R0 => { 
                        self.bsr_set.add(Label::SyntaxAlternate1R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::SyntaxAlternate) {
                            self.rtn(NT::SyntaxAlternate, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::SyntaxAlternate1R0, self.c_i, NT::SyntaxAlternate)
                        }
                    }, 
                    // SyntaxAlternates : ∙SyntaxAlternate 
                    Label::SyntaxAlternates0R0 => { 
                        self.call(Label::SyntaxAlternates0R1, c_u, self.c_i);
                    },
                    // SyntaxAlternates : SyntaxAlternate ∙
                    Label::SyntaxAlternates0R1 => {
                        if self.follow(NT::SyntaxAlternates) {
                            self.rtn(NT::SyntaxAlternates, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::SyntaxAlternates0R0, self.c_i, NT::SyntaxAlternates)
                        }
                    }, 
                    // SyntaxAlternates : ∙SyntaxAlternate | SyntaxAlternates 
                    Label::SyntaxAlternates1R0 => { 
                        self.call(Label::SyntaxAlternates1R1, c_u, self.c_i);
                    },
                    // SyntaxAlternates : SyntaxAlternate ∙| SyntaxAlternates 
                    Label::SyntaxAlternates1R1 => {
                        if !self.test_select(Label::SyntaxAlternates1R1){ 
                            self.error_first(Label::SyntaxAlternates1R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::SyntaxAlternates1R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::SyntaxAlternates1R2){ 
                            self.error_first(Label::SyntaxAlternates1R2, self.c_i);
                            return; 
                        }
                        self.call(Label::SyntaxAlternates1R3, c_u, self.c_i);
                    },
                    // SyntaxAlternates : SyntaxAlternate | SyntaxAlternates ∙
                    Label::SyntaxAlternates1R3 => {
                        if self.follow(NT::SyntaxAlternates) {
                            self.rtn(NT::SyntaxAlternates, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::SyntaxAlternates1R0, self.c_i, NT::SyntaxAlternates)
                        }
                    }, 
                    // SyntaxRule : ∙nt : SyntaxAlternates ; 
                    Label::SyntaxRule0R0 => { 
                        self.bsr_set.add(Label::SyntaxRule0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::SyntaxRule0R1){ 
                            self.error_first(Label::SyntaxRule0R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::SyntaxRule0R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::SyntaxRule0R2){ 
                            self.error_first(Label::SyntaxRule0R2, self.c_i);
                            return; 
                        }
                        self.call(Label::SyntaxRule0R3, c_u, self.c_i);
                    },
                    // SyntaxRule : nt : SyntaxAlternates ∙; 
                    Label::SyntaxRule0R3 => {
                        if !self.test_select(Label::SyntaxRule0R3){ 
                            self.error_first(Label::SyntaxRule0R3, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::SyntaxRule0R4, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::SyntaxRule) {
                            self.rtn(NT::SyntaxRule, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::SyntaxRule0R0, self.c_i, NT::SyntaxRule)
                        }
                    }, 
                    // SyntaxSymbol : ∙nt 
                    Label::SyntaxSymbol0R0 => { 
                        self.bsr_set.add(Label::SyntaxSymbol0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::SyntaxSymbol) {
                            self.rtn(NT::SyntaxSymbol, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::SyntaxSymbol0R0, self.c_i, NT::SyntaxSymbol)
                        }
                    }, 
                    // SyntaxSymbol : ∙tokid 
                    Label::SyntaxSymbol1R0 => { 
                        self.bsr_set.add(Label::SyntaxSymbol1R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::SyntaxSymbol) {
                            self.rtn(NT::SyntaxSymbol, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::SyntaxSymbol1R0, self.c_i, NT::SyntaxSymbol)
                        }
                    }, 
                    // SyntaxSymbol : ∙string_lit 
                    Label::SyntaxSymbol2R0 => { 
                        self.bsr_set.add(Label::SyntaxSymbol2R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::SyntaxSymbol) {
                            self.rtn(NT::SyntaxSymbol, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::SyntaxSymbol2R0, self.c_i, NT::SyntaxSymbol)
                        }
                    }, 
                    // SyntaxSymbols : ∙SyntaxSymbol 
                    Label::SyntaxSymbols0R0 => { 
                        self.call(Label::SyntaxSymbols0R1, c_u, self.c_i);
                    },
                    // SyntaxSymbols : SyntaxSymbol ∙
                    Label::SyntaxSymbols0R1 => {
                        if self.follow(NT::SyntaxSymbols) {
                            self.rtn(NT::SyntaxSymbols, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::SyntaxSymbols0R0, self.c_i, NT::SyntaxSymbols)
                        }
                    }, 
                    // SyntaxSymbols : ∙SyntaxSymbol SyntaxSymbols 
                    Label::SyntaxSymbols1R0 => { 
                        self.call(Label::SyntaxSymbols1R1, c_u, self.c_i);
                    },
                    // SyntaxSymbols : SyntaxSymbol ∙SyntaxSymbols 
                    Label::SyntaxSymbols1R1 => {
                        if !self.test_select(Label::SyntaxSymbols1R1){ 
                            self.error_first(Label::SyntaxSymbols1R1, self.c_i);
                            return; 
                        }
                        self.call(Label::SyntaxSymbols1R2, c_u, self.c_i);
                    },
                    // SyntaxSymbols : SyntaxSymbol SyntaxSymbols ∙
                    Label::SyntaxSymbols1R2 => {
                        if self.follow(NT::SyntaxSymbols) {
                            self.rtn(NT::SyntaxSymbols, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::SyntaxSymbols1R0, self.c_i, NT::SyntaxSymbols)
                        }
                    }, 
                    // UnicodeClass : ∙letter 
                    Label::UnicodeClass0R0 => { 
                        self.bsr_set.add(Label::UnicodeClass0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::UnicodeClass) {
                            self.rtn(NT::UnicodeClass, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::UnicodeClass0R0, self.c_i, NT::UnicodeClass)
                        }
                    }, 
                    // UnicodeClass : ∙upcase 
                    Label::UnicodeClass1R0 => { 
                        self.bsr_set.add(Label::UnicodeClass1R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::UnicodeClass) {
                            self.rtn(NT::UnicodeClass, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::UnicodeClass1R0, self.c_i, NT::UnicodeClass)
                        }
                    }, 
                    // UnicodeClass : ∙lowcase 
                    Label::UnicodeClass2R0 => { 
                        self.bsr_set.add(Label::UnicodeClass2R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::UnicodeClass) {
                            self.rtn(NT::UnicodeClass, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::UnicodeClass2R0, self.c_i, NT::UnicodeClass)
                        }
                    }, 
                    // UnicodeClass : ∙number 
                    Label::UnicodeClass3R0 => { 
                        self.bsr_set.add(Label::UnicodeClass3R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::UnicodeClass) {
                            self.rtn(NT::UnicodeClass, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::UnicodeClass3R0, self.c_i, NT::UnicodeClass)
                        }
                    }, 
                    _ => unimplemented!()
                };
            })();
        };
    }
    
    fn nt_add(&mut self, nt: NT, j: usize) {
        // println!("nt_add({},{}", nt, j);

        let mut failed = true;
        let mut expected: HashSet<token::Type> = HashSet::with_capacity(128);
        for l in slot::get_alternates(&nt).iter() {
            if self.test_select(*l) {
                self.dsc_add(*l, j, j);
                failed = false
            } else {
                for tok in FIRST[l].iter() {
                    expected.insert(tok.clone());
                }
            }
        }
        if failed {
            for l in slot::get_alternates(&nt) {
                self.error_first(*l, j)
            }
        }
    }

    /*
    suppose that L is Y ::=αX ·β
    if there is no CRF node labelled (L,i)
        create one let u be the CRF node labelled (L,i)
    if there is no CRF node labelled (X, j) {
        create a CRF node v labelled (X, j)
        create an edge from v to u
        nt_add(X, j)
    } else {
        let v be the CRF node labelled (X, j)
        if there is not an edge from v to u {
            create an edge from v to u
            for all ((X, j,h)∈P) {
                dscAdd(L, i, h);
                bsrAdd(L, i, j, h)
            }
        }
    }
    */
    fn call(&mut self, l: Label, i: usize, j: usize) {
        let u = CRFNode::new(l, i);
        if let None = self.crf_nodes.get(&u) {
            self.crf_nodes.insert(u);
        }
        let x = match l.symbols()[l.pos()-1]{
            Symbol::NT(x) => x,
            _ => panic!("Symbol::T is invalid"),
        };
        let nd_v = ClusterNode::new(x, j);
        match self.crf.get_mut(&nd_v) {
            None => {
                let mut m: HashSet<CRFNode> = HashSet::with_capacity(128);
                m.insert(u);
                self.crf.insert(nd_v, m);
                self.nt_add(x, j);
            },
            Some(v) => {
                if !v.contains(&u) {
                    v.insert(u);
                    let mut descs: Vec<Rc<Descriptor>> = Vec::new();
                    for pnd in self.popped.iter() {
                        if pnd.x == x && pnd.k == j {
                            descs.push(Descriptor::new(l, i, pnd.j));
                            self.bsr_set.add(l, i, j, pnd.j);
                        }
                    }
                    for d in descs.into_iter() {
                        self.dsc_add(d.l, d.k, d.i)
                    }
                }
            }
        }
    }
    
    fn rtn(&mut self, x: NT, k: usize, j: usize) {
        let pn = PoppedNode::new(x, k, j);
        if !self.popped.contains(&pn) {
            self.popped.insert(pn);
            for nd in self.crf[&ClusterNode::new(x, k)].clone() {
                self.dsc_add(nd.l, nd.i, j);
                self.bsr_set.add(nd.l, nd.i, k, j);
            }
        }
    }
    
    fn dsc_add(&mut self, l: Label, k: usize, i: usize) {
        let d = Descriptor::new(l, k, i);
        if !self.u.contains(&d) {
            self.r.push(d.clone());
            self.u.push(d.clone());
        }
    }
    
    fn r_remove(&mut self) -> (Label, usize, usize) {
        match self.r.pop() {
            Some(d) => return (d.l, d.k, d.i),
            None => panic!("empty")
        }
    }

    fn error_first(&mut self, l: Label, i: usize) {
        self.errors.push(
            Box::new(ParseError{
                c_i: i, 
                slot: l, 
                token: self.lex.tokens[i].clone(), 
                expected: Expected::First,
            })
        );
    }

    fn error_follow(&mut self, l: Label, i: usize, nt: NT) {
        self.errors.push(
            Box::new(ParseError{
                c_i: i, 
                slot: l, 
                token: self.lex.tokens[i].clone(), 
                expected: Expected::Follow(nt),
            })
        );
    }

    fn export_errors(&mut self) -> Vec<Box<Error>> {
        let mut errs: Vec<Box<Error>> = Vec::new();
        self.errors.sort_by(|a,b| a.token.lext.cmp(&b.token.lext));
        for err in self.errors.iter() {
            let (ln, col) = self.lex.get_line_column(err.token.lext);
            errs.push(Box::new(Error{
                c_i: err.c_i,
                slot: err.slot,
                token: err.token.clone(),
                expected: match err.expected {
                    Expected::First => FIRST[&err.slot].clone(),
                    Expected::Follow(nt) => FOLLOW[&nt].clone(),
                },
                line: ln,
                column: col,
            }));
        }
        errs
    }
    
    fn test_select(&self, l: Label) -> bool {
        FIRST[&l].contains(&self.lex.tokens[self.c_i].typ)
    }

    fn follow(&self, nt: NT) -> bool {
        FOLLOW[&nt].contains(&self.lex.tokens[self.c_i].typ)
    }
    
} /*** impl Parser ***/

impl ClusterNode {
    fn new(nt: NT, k: usize) -> ClusterNode {
        ClusterNode{
            x: nt,
            k: k,
        }
    }
}

impl CRFNode {
    fn new(l: Label, i: usize) -> CRFNode {
        CRFNode{
            l: l,
            i: i,
        }
    }
}

impl Descriptor {
    fn new(l: Label, k: usize, i: usize) -> Rc<Descriptor> {
        Rc::new(Descriptor{
            l: l,
            k: k,
            i: i,
        })
    }
}

impl PoppedNode {
    fn new(x: NT, k: usize, j: usize) -> Box<PoppedNode> {
        Box::new(PoppedNode{
            x: x,
            k: k,
            j: j,
        })
    }
}

impl fmt::Display for Descriptor {    
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "l={l},k={k},i={i}", 
            l=self.l,
            k=self.k,
            i=self.i,
        )
    }
}
    
impl fmt::Display for Error {    
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut errs: Vec<String> = Vec::new();
        for tok in self.expected.iter() {
            errs.push(format!("{}",tok));
        };
        write!(f, "Error: {slot}, token {tok}, expected {{{exp}}} at line {ln} col {col}", 
            slot=self.slot,
            tok=self.token,
            exp=errs.join(","),
            ln=self.line,
            col=self.column,
        )
    }
}
    
    lazy_static! {
    static ref FIRST: HashMap<Label, Box<HashSet<token::Type>>> = {
        let mut fmap = HashMap::new(); 
        // GoGLL : ∙Package Rules 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type17); // package 
            fmap.insert(Label::GoGLL0R0, hset);
        // GoGLL : Package ∙Rules 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::GoGLL0R1, hset);
        // GoGLL : Package Rules ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // EOF 
            fmap.insert(Label::GoGLL0R2, hset);
        // LexAlternates : ∙RegExp 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            fmap.insert(Label::LexAlternates0R0, hset);
        // LexAlternates : RegExp ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::LexAlternates0R1, hset);
        // LexAlternates : ∙RegExp | LexAlternates 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            fmap.insert(Label::LexAlternates1R0, hset);
        // LexAlternates : RegExp ∙| LexAlternates 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type22); // | 
            fmap.insert(Label::LexAlternates1R1, hset);
        // LexAlternates : RegExp | ∙LexAlternates 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            fmap.insert(Label::LexAlternates1R2, hset);
        // LexAlternates : RegExp | LexAlternates ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::LexAlternates1R3, hset);
        // LexBracket : ∙LexGroup 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            fmap.insert(Label::LexBracket0R0, hset);
        // LexBracket : LexGroup ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::LexBracket0R1, hset);
        // LexBracket : ∙LexOptional 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type7); // [ 
            fmap.insert(Label::LexBracket1R0, hset);
        // LexBracket : LexOptional ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::LexBracket1R1, hset);
        // LexBracket : ∙LexZeroOrMore 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type21); // { 
            fmap.insert(Label::LexBracket2R0, hset);
        // LexBracket : LexZeroOrMore ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::LexBracket2R1, hset);
        // LexBracket : ∙LexOneOrMore 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type5); // < 
            fmap.insert(Label::LexBracket3R0, hset);
        // LexBracket : LexOneOrMore ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::LexBracket3R1, hset);
        // LexGroup : ∙( LexAlternates ) 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            fmap.insert(Label::LexGroup0R0, hset);
        // LexGroup : ( ∙LexAlternates ) 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            fmap.insert(Label::LexGroup0R1, hset);
        // LexGroup : ( LexAlternates ∙) 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type1); // ) 
            fmap.insert(Label::LexGroup0R2, hset);
        // LexGroup : ( LexAlternates ) ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::LexGroup0R3, hset);
        // LexOneOrMore : ∙< LexAlternates > 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type5); // < 
            fmap.insert(Label::LexOneOrMore0R0, hset);
        // LexOneOrMore : < ∙LexAlternates > 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            fmap.insert(Label::LexOneOrMore0R1, hset);
        // LexOneOrMore : < LexAlternates ∙> 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type6); // > 
            fmap.insert(Label::LexOneOrMore0R2, hset);
        // LexOneOrMore : < LexAlternates > ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::LexOneOrMore0R3, hset);
        // LexOptional : ∙[ LexAlternates ] 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type7); // [ 
            fmap.insert(Label::LexOptional0R0, hset);
        // LexOptional : [ ∙LexAlternates ] 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            fmap.insert(Label::LexOptional0R1, hset);
        // LexOptional : [ LexAlternates ∙] 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type8); // ] 
            fmap.insert(Label::LexOptional0R2, hset);
        // LexOptional : [ LexAlternates ] ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::LexOptional0R3, hset);
        // LexRule : ∙tokid : RegExp ; 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::LexRule0R0, hset);
        // LexRule : tokid ∙: RegExp ; 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type3); // : 
            fmap.insert(Label::LexRule0R1, hset);
        // LexRule : tokid : ∙RegExp ; 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            fmap.insert(Label::LexRule0R2, hset);
        // LexRule : tokid : RegExp ∙; 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type4); // ; 
            fmap.insert(Label::LexRule0R3, hset);
        // LexRule : tokid : RegExp ; ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // EOF 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::LexRule0R4, hset);
        // LexSymbol : ∙. 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type2); // . 
            fmap.insert(Label::LexSymbol0R0, hset);
        // LexSymbol : . ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::LexSymbol0R1, hset);
        // LexSymbol : ∙any string_lit 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type9); // any 
            fmap.insert(Label::LexSymbol1R0, hset);
        // LexSymbol : any ∙string_lit 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type18); // string_lit 
            fmap.insert(Label::LexSymbol1R1, hset);
        // LexSymbol : any string_lit ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::LexSymbol1R2, hset);
        // LexSymbol : ∙char_lit 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type10); // char_lit 
            fmap.insert(Label::LexSymbol2R0, hset);
        // LexSymbol : char_lit ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::LexSymbol2R1, hset);
        // LexSymbol : ∙LexBracket 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type21); // { 
            fmap.insert(Label::LexSymbol3R0, hset);
        // LexSymbol : LexBracket ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::LexSymbol3R1, hset);
        // LexSymbol : ∙not string_lit 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type14); // not 
            fmap.insert(Label::LexSymbol4R0, hset);
        // LexSymbol : not ∙string_lit 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type18); // string_lit 
            fmap.insert(Label::LexSymbol4R1, hset);
        // LexSymbol : not string_lit ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::LexSymbol4R2, hset);
        // LexSymbol : ∙UnicodeClass 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            fmap.insert(Label::LexSymbol5R0, hset);
        // LexSymbol : UnicodeClass ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::LexSymbol5R1, hset);
        // LexZeroOrMore : ∙{ LexAlternates } 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type21); // { 
            fmap.insert(Label::LexZeroOrMore0R0, hset);
        // LexZeroOrMore : { ∙LexAlternates } 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            fmap.insert(Label::LexZeroOrMore0R1, hset);
        // LexZeroOrMore : { LexAlternates ∙} 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::LexZeroOrMore0R2, hset);
        // LexZeroOrMore : { LexAlternates } ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::LexZeroOrMore0R3, hset);
        // Package : ∙package string_lit 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type17); // package 
            fmap.insert(Label::Package0R0, hset);
        // Package : package ∙string_lit 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type18); // string_lit 
            fmap.insert(Label::Package0R1, hset);
        // Package : package string_lit ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::Package0R2, hset);
        // RegExp : ∙LexSymbol 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            fmap.insert(Label::RegExp0R0, hset);
        // RegExp : LexSymbol ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::RegExp0R1, hset);
        // RegExp : ∙LexSymbol RegExp 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            fmap.insert(Label::RegExp1R0, hset);
        // RegExp : LexSymbol ∙RegExp 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            fmap.insert(Label::RegExp1R1, hset);
        // RegExp : LexSymbol RegExp ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::RegExp1R2, hset);
        // Rule : ∙LexRule 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::Rule0R0, hset);
        // Rule : LexRule ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // EOF 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::Rule0R1, hset);
        // Rule : ∙SyntaxRule 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type15); // nt 
            fmap.insert(Label::Rule1R0, hset);
        // Rule : SyntaxRule ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // EOF 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::Rule1R1, hset);
        // Rules : ∙Rule 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::Rules0R0, hset);
        // Rules : Rule ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // EOF 
            fmap.insert(Label::Rules0R1, hset);
        // Rules : ∙Rule Rules 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::Rules1R0, hset);
        // Rules : Rule ∙Rules 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::Rules1R1, hset);
        // Rules : Rule Rules ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // EOF 
            fmap.insert(Label::Rules1R2, hset);
        // SyntaxAlternate : ∙SyntaxSymbols 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type18); // string_lit 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::SyntaxAlternate0R0, hset);
        // SyntaxAlternate : SyntaxSymbols ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type22); // | 
            fmap.insert(Label::SyntaxAlternate0R1, hset);
        // SyntaxAlternate : ∙empty 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type11); // empty 
            fmap.insert(Label::SyntaxAlternate1R0, hset);
        // SyntaxAlternate : empty ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type22); // | 
            fmap.insert(Label::SyntaxAlternate1R1, hset);
        // SyntaxAlternates : ∙SyntaxAlternate 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type11); // empty 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type18); // string_lit 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::SyntaxAlternates0R0, hset);
        // SyntaxAlternates : SyntaxAlternate ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type4); // ; 
            fmap.insert(Label::SyntaxAlternates0R1, hset);
        // SyntaxAlternates : ∙SyntaxAlternate | SyntaxAlternates 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type11); // empty 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type18); // string_lit 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::SyntaxAlternates1R0, hset);
        // SyntaxAlternates : SyntaxAlternate ∙| SyntaxAlternates 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type22); // | 
            fmap.insert(Label::SyntaxAlternates1R1, hset);
        // SyntaxAlternates : SyntaxAlternate | ∙SyntaxAlternates 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type11); // empty 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type18); // string_lit 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::SyntaxAlternates1R2, hset);
        // SyntaxAlternates : SyntaxAlternate | SyntaxAlternates ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type4); // ; 
            fmap.insert(Label::SyntaxAlternates1R3, hset);
        // SyntaxRule : ∙nt : SyntaxAlternates ; 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type15); // nt 
            fmap.insert(Label::SyntaxRule0R0, hset);
        // SyntaxRule : nt ∙: SyntaxAlternates ; 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type3); // : 
            fmap.insert(Label::SyntaxRule0R1, hset);
        // SyntaxRule : nt : ∙SyntaxAlternates ; 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type11); // empty 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type18); // string_lit 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::SyntaxRule0R2, hset);
        // SyntaxRule : nt : SyntaxAlternates ∙; 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type4); // ; 
            fmap.insert(Label::SyntaxRule0R3, hset);
        // SyntaxRule : nt : SyntaxAlternates ; ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // EOF 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::SyntaxRule0R4, hset);
        // SyntaxSymbol : ∙nt 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type15); // nt 
            fmap.insert(Label::SyntaxSymbol0R0, hset);
        // SyntaxSymbol : nt ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type18); // string_lit 
            hset.insert(token::Type::Type19); // tokid 
            hset.insert(token::Type::Type22); // | 
            fmap.insert(Label::SyntaxSymbol0R1, hset);
        // SyntaxSymbol : ∙tokid 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::SyntaxSymbol1R0, hset);
        // SyntaxSymbol : tokid ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type18); // string_lit 
            hset.insert(token::Type::Type19); // tokid 
            hset.insert(token::Type::Type22); // | 
            fmap.insert(Label::SyntaxSymbol1R1, hset);
        // SyntaxSymbol : ∙string_lit 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type18); // string_lit 
            fmap.insert(Label::SyntaxSymbol2R0, hset);
        // SyntaxSymbol : string_lit ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type18); // string_lit 
            hset.insert(token::Type::Type19); // tokid 
            hset.insert(token::Type::Type22); // | 
            fmap.insert(Label::SyntaxSymbol2R1, hset);
        // SyntaxSymbols : ∙SyntaxSymbol 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type18); // string_lit 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::SyntaxSymbols0R0, hset);
        // SyntaxSymbols : SyntaxSymbol ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type22); // | 
            fmap.insert(Label::SyntaxSymbols0R1, hset);
        // SyntaxSymbols : ∙SyntaxSymbol SyntaxSymbols 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type18); // string_lit 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::SyntaxSymbols1R0, hset);
        // SyntaxSymbols : SyntaxSymbol ∙SyntaxSymbols 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type18); // string_lit 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(Label::SyntaxSymbols1R1, hset);
        // SyntaxSymbols : SyntaxSymbol SyntaxSymbols ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type22); // | 
            fmap.insert(Label::SyntaxSymbols1R2, hset);
        // UnicodeClass : ∙letter 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type12); // letter 
            fmap.insert(Label::UnicodeClass0R0, hset);
        // UnicodeClass : letter ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::UnicodeClass0R1, hset);
        // UnicodeClass : ∙upcase 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type20); // upcase 
            fmap.insert(Label::UnicodeClass1R0, hset);
        // UnicodeClass : upcase ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::UnicodeClass1R1, hset);
        // UnicodeClass : ∙lowcase 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type13); // lowcase 
            fmap.insert(Label::UnicodeClass2R0, hset);
        // UnicodeClass : lowcase ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::UnicodeClass2R1, hset);
        // UnicodeClass : ∙number 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type16); // number 
            fmap.insert(Label::UnicodeClass3R0, hset);
        // UnicodeClass : number ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(Label::UnicodeClass3R1, hset);
        fmap
    };

    static ref FOLLOW: HashMap<NT, Box<HashSet<token::Type>>> = {
        let mut fmap = HashMap::new(); 
        // GoGLL
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // EOF 
            fmap.insert(NT::GoGLL, hset);
        // LexAlternates
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(NT::LexAlternates, hset);
        // LexBracket
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(NT::LexBracket, hset);
        // LexGroup
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(NT::LexGroup, hset);
        // LexOneOrMore
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(NT::LexOneOrMore, hset);
        // LexOptional
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(NT::LexOptional, hset);
        // LexRule
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // EOF 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(NT::LexRule, hset);
        // LexSymbol
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(NT::LexSymbol, hset);
        // LexZeroOrMore
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(NT::LexZeroOrMore, hset);
        // Package
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(NT::Package, hset);
        // RegExp
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(NT::RegExp, hset);
        // Rule
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // EOF 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(NT::Rule, hset);
        // Rules
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // EOF 
            fmap.insert(NT::Rules, hset);
        // SyntaxAlternate
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type22); // | 
            fmap.insert(NT::SyntaxAlternate, hset);
        // SyntaxAlternates
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type4); // ; 
            fmap.insert(NT::SyntaxAlternates, hset);
        // SyntaxRule
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // EOF 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type19); // tokid 
            fmap.insert(NT::SyntaxRule, hset);
        // SyntaxSymbol
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type15); // nt 
            hset.insert(token::Type::Type18); // string_lit 
            hset.insert(token::Type::Type19); // tokid 
            hset.insert(token::Type::Type22); // | 
            fmap.insert(NT::SyntaxSymbol, hset);
        // SyntaxSymbols
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type22); // | 
            fmap.insert(NT::SyntaxSymbols, hset);
        // UnicodeClass
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::Type0); // ( 
            hset.insert(token::Type::Type1); // ) 
            hset.insert(token::Type::Type2); // . 
            hset.insert(token::Type::Type4); // ; 
            hset.insert(token::Type::Type5); // < 
            hset.insert(token::Type::Type6); // > 
            hset.insert(token::Type::Type7); // [ 
            hset.insert(token::Type::Type8); // ] 
            hset.insert(token::Type::Type9); // any 
            hset.insert(token::Type::Type10); // char_lit 
            hset.insert(token::Type::Type12); // letter 
            hset.insert(token::Type::Type13); // lowcase 
            hset.insert(token::Type::Type14); // not 
            hset.insert(token::Type::Type16); // number 
            hset.insert(token::Type::Type20); // upcase 
            hset.insert(token::Type::Type21); // { 
            hset.insert(token::Type::Type22); // | 
            hset.insert(token::Type::Type23); // } 
            fmap.insert(NT::UnicodeClass, hset);
        fmap
    };
}

