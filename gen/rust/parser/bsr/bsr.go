//  Copyright 2020 Marius Ackerman
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// Package bsr generates Rust code for the parser NTBSR module
package bsr

import (
	"github.com/goccmack/goutil/ioutil"
)

func Gen(bsrFile string) {
	if err := ioutil.WriteFile(bsrFile, []byte(bsrTmpl)); err != nil {
		panic(err)
	}
}

const bsrTmpl = `
// Module bsr is generated by gogll. Do not edit.

/*
Module bsr implements a Binary Subtree Representation set as defined in

    Scott et al
    Derivation representation using binary subtree sets,
    Science of Computer Programming 175 (2019)

ToDo:

* StrBSR is specific to a grammar slot rather than a symbol string. In an
ambiguous grammar this leads to more string BSRs than necessary.
*/

use crate::lexer;
use crate::parser::{slot, symbols};
use crate::parser::symbols::{NT, Symbol};
use crate::token::{Token};

use std::collections::HashMap;
use std::rc::Rc;
use std::fmt;

enum bsr {
    NT(Rc<BSR>),
    Str(Rc<BSR>),
}

/**
Set contains the set of Binary Subtree Representations (BSR).
*/
#[allow(dead_code)]
pub struct Set {
    slot_entries: HashMap<Rc<BSR>, bool>,
    nt_slot_entries: HashMap<NTSlot, Vec<Rc<BSR>>>,
    string_entries: HashMap<Rc<BSR>, bool>,
    pub rext: usize,
    lex: Rc<lexer::Lexer>,

    start_sym: NT,
}

#[derive(Hash, Eq, PartialEq)]
struct NTSlot {
    nt: NT,
    lext: usize,
    rext: usize,
}

/// BSR is the binary subtree representation of a parsed nonterminal
#[derive(Hash, Eq, PartialEq)]
pub struct BSR {
    label: slot::Label,
    lext: usize,
    pivot: usize,
    rext: usize,
}

impl Set {
    /// New returns a new initialised BSR Set
    #[allow(dead_code)]
    pub fn new(start_symbol: &NT, l: Rc<lexer::Lexer>) -> Rc<Set> {
        Rc::new(Set {
            slot_entries: HashMap::new(),
            nt_slot_entries: HashMap::new(),
            string_entries: HashMap::new(),
            rext: 0,
            lex: l.clone(),
            start_sym: start_symbol.clone(),
        })
    }

    /// Add a BSR to the set. (i,j) is the extent. k is the pivot.
    #[allow(dead_code)]
    pub fn add(&mut self, l: &slot::Label, i: usize, k: usize, j: usize) {
        let b = Rc::new(BSR {
            label: l.clone(),
            lext: i,
            pivot: k,
            rext: j,
        });
        if l.eor() {
            self.insert(bsr::NT(b))
        } else {
            if l.pos() > 1 {
                self.insert(bsr::Str(b))
            }
        }
    }

    /// Returns the index of the grammar rule alternate.
    #[allow(dead_code)]
    pub fn alternate(&self, b: Rc<BSR>) -> usize {
    	return b.label.alternate()
    }

    fn insert(&mut self, bsr: bsr) {
        if bsr.rext() > self.rext {
            self.rext = bsr.rext()
        }
        match bsr {
            bsr::NT(b) => {
                self.slot_entries.insert(b.clone(), true);
                let nt_slot = NTSlot::new(b.label.head(), b.lext, b.rext);
                match self.nt_slot_entries.get_mut(&nt_slot) {
                    None => {
                        self.nt_slot_entries.insert(nt_slot, vec![b.clone()]);
                    },
                    Some(bsrs) => bsrs.push(b.clone())
                }
            }
            bsr::Str(b) => {
                self.string_entries.insert(b.clone(), true);
            }
        };
    }

    /// AddEmpty adds a grammar slot: X : ϵ•
    #[allow(dead_code)]
    pub fn add_empty(&mut self, l: slot::Label, i: usize) {
        self.insert(bsr::NT(Rc::new(BSR {
            label: l,
            lext: i,
            pivot: i,
            rext: i,
        })))
    }

    /**
    contain returns true iff the BSR Set contains the NT symbol with left and
    right extent.
    */
    #[allow(dead_code)]
    pub fn contain(&self, nt: &NT, left: usize, right: usize) -> bool {
        for e in self.slot_entries.keys() {
            if e.label.head() == nt && e.lext == left && e.rext == right {
                return true;
            }
        }
        return false;
    }

    // get_root returns the root of the parse tree of an unambiguous parse.
    // get_root fails if the parse was ambiguous. Use get_roots() for ambiguous parses.
    #[allow(dead_code)]
    pub fn get_root(&self) -> Rc<BSR> {
        let rts = self.get_roots();
        if rts.len() != 1 {
            fail(format!("{} parse trees exist for start symbol {}", 
            rts.len(), self.start_sym))
        }
        return rts[0].clone()
    }

    // get_roots returns all the roots of parse trees of the start symbol of the grammar.
    #[allow(dead_code)]
    pub fn get_roots(&self) -> Vec<Rc<BSR>> {
        let mut roots: Vec<Rc<BSR>> = Vec::new();
        for b in self.slot_entries.keys() {
            if b.label.head() == &self.start_sym && b.lext == 0 && self.rext == self.rext {
                roots.push(b.clone())
            }
        }
        roots
    }

    /// Return the (line, column) of the left extent of token `i`.
    fn get_line_column(&self, i: usize) -> (usize, usize) {
    	return self.lex.get_line_column_of_token(i)
    }

    // get_nt_child_i returns the BSR of NT symbol[i] in the BSR set.
    // get_nt_child_i fails if the BSR set has ambiguous subtrees of NT i.
    #[allow(dead_code)]
    pub fn get_nt_child_i(&self, b: Rc<BSR>, i: usize) -> Rc<BSR> {
        let bsrs = self.get_nt_children_i(b.clone(), i);
        if bsrs.len() != 1 {
            panic!("NT {} is ambiguous in {}", i, b.clone());
        }
        return bsrs[0].clone()
    }

    // get_nt_children_i returns all the BSRs of NT symbol[i] in s
    #[allow(dead_code)]
    pub fn get_nt_children_i(&self, b: Rc<BSR>, i: usize) -> &Vec<Rc<BSR>> {
        if i >= b.label.symbols().len() {
            fail(format!("Error: cannot get NT child {} of {}", i, b))
        }
        if b.label.symbols().len() == 1 {
            return self.get_nt_slot(&b.label.symbols()[i], b.pivot, b.rext)
        }
        if b.label.symbols().len() == 2 {
            if i == 0 {
                return self.get_nt_slot(&b.label.symbols()[i], b.lext, b.pivot)
            }
            return self.get_nt_slot(&b.label.symbols()[i], b.pivot, b.rext)
        }
        let mut idx = b.label.index();
        let mut strBsr = Rc::new(BSR{label: b.label, lext: b.lext, pivot: b.pivot, rext: b.rext});
        while idx.pos > i+1 && idx.pos > 2 {
            idx.pos -= 1;
            strBsr = self.get_string(slot::get_label(&idx.nt, idx.alt, idx.pos), 
                strBsr.lext, strBsr.pivot);
        }
        if i == 0 {
            return self.get_nt_slot(&b.label.symbols()[i], strBsr.lext, strBsr.pivot)
        }
        return self.get_nt_slot(&b.label.symbols()[i], strBsr.pivot, strBsr.rext)
    }

    fn get_nt_slot(&self, sym: &Symbol, lext: usize, rext: usize) -> &Vec<Rc<BSR>> {
        if let Symbol::NT(nt) = sym {
            if let Some(bsrs) = self.nt_slot_entries.get(&NTSlot::new(&nt, lext, rext)) {
                return bsrs
            }
            panic!("{} ({},{}) has no slot entry", nt, lext, rext)
        }
        let (line, col) = self.get_line_column(lext);
        panic!("{} is not an NT at line {} col {}", sym, line, col);
    }
    
    fn get_string(&self, l: slot::Label, lext: usize, rext: usize) -> Rc<BSR> {
        for st in self.string_entries.keys() {
            if st.label == l && st.lext == lext && st.rext == rext {
                return st.clone()
            }
        }
        panic!("Error: no string BSR {} left extent={} right extent={} pos={}",
            symbols::to_string(l.symbols()), lext, rext, l.pos())
    }

    /**
    GetTChildI returns the terminal symbol at position i in b.   
    GetTChildI panics if symbol i is not a valid terminal
    */
    #[allow(dead_code)]
    pub fn get_t_child_i(&self, b: Rc<BSR>, i: usize) -> Rc<Token> {
        if i >= b.label.symbols().len() {
            panic!("{} has no T child {}", b, i);
        }
        if b.label.symbols()[i].is_nt() {
            panic!("symbol {} in {} is an NT", i, b);
        }
        self.lex.tokens[b.lext+i].clone()
    }

    /// Returns true if the BSR set does not have exactly one root, or
    /// if any BSR in the set has an NT symbol, which does not have exactly one
    /// sub-tree.
    #[allow(dead_code)]
    pub fn is_ambiguous(&self) -> bool {
        if self.get_roots().len() != 1 {
            return true
        }
        self.is_ambiguous_bsr(self.get_root())
    }

    /// Returns true if b or any of its NT children is ambiguous.
    /// A BSR is ambigous if any of its NT symbols does not have exactly one
    /// subtrees (children).
    fn is_ambiguous_bsr(&self, b: Rc<BSR>) -> bool {
        for (i, s) in b.label.symbols().iter().enumerate() {
            if s.is_nt() {
                if self.get_nt_children_i(b.clone(), i).len() != 1 {
                    return true
                }
                for b1 in self.get_nt_children_i(b.clone(), i).iter() {
                    if self.is_ambiguous_bsr(b1.clone()) {
                        return true
                    }
                }
            }
        }
        return false
    }

} // impl Set

impl bsr {
    fn rext(&self) -> usize {
        match self {
            bsr::NT(b) => b.rext,
            bsr::Str(b) => b.rext,
        }
    }
}

impl NTSlot {
    fn new(nt: &NT, lext: usize, rext: usize) -> NTSlot {
        NTSlot{
            nt: nt.clone(), 
            lext: lext,
            rext: rext,
        }
    }
}

impl fmt::Display for BSR {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "({} ({},{},{})", self.label, self.lext, self.pivot, self.rext)
    }
}

fn fail(msg: String) {
	panic!("Error in BSR: {}", msg)
}



// // GetAll returns all BSR grammar slot entries
// func (s *Set) GetAll() (bsrs []BSR) {
// 	for b := range s.slot_entries {
// 		bsrs = append(bsrs, b)
// 	}
// 	return
// }

// // GetAllNTChildren returns all the NT Children of b. If an NT child of b has
// // ambiguous parses then all parses of that child are returned.
// func (b BSR) GetAllNTChildren() [][]BSR {
// 	children := [][]BSR{}
// 	for i, s := range b.label.symbols() {
// 		if s.IsNonTerminal() {
// 			sChildren := b.get_nt_children_i(i)
// 			children = append(children, sChildren)
// 		}
// 	}
// 	return children
// }

// // GetNTChild returns the BSR of occurrence i of nt in s.
// // GetNTChild fails if s has ambiguous subtrees of occurrence i of nt.
// func (b BSR) GetNTChild(nt symbols.NT, i int) BSR {
// 	bsrs := b.GetNTChildren(nt, i)
// 	if len(bsrs) != 1 {
// 		ambiguousSlots := []string{}
// 		for _, c := range bsrs {
// 			ambiguousSlots = append(ambiguousSlots, c.String())
// 		}
// 		fail(b, "%s is ambiguous in %s\n  %s", nt, b, strings.Join(ambiguousSlots, "\n  "))
// 	}
// 	return bsrs[0]
// }

// // GetNTChildren returns all the BSRs of occurrence i of nt in s
// func (b BSR) GetNTChildren(nt symbols.NT, i int) []BSR {
// 	// fmt.Printf("GetNTChild(%s,%d) %s\n", nt, i, b)
// 	positions := []int{}
// 	for j, s := range b.label.symbols() {
// 		if s == nt {
// 			positions = append(positions, j)
// 		}
// 	}
// 	if len(positions) == 0 {
// 		fail(b, "Error: %s has no NT %s", b, nt)
// 	}
// 	return b.get_nt_children_i(positions[i])
// }

// // func (b BSR) GetString() string {
// // 	return set.lex.GetString(b.LeftExtent(),b.RightExtent())
// // }

// func deleteNTSlotEntry(b BSR) {
// 	// fmt.Printf("deletNTSlotEntry(%s)\n", b)
// 	nts := NTSlot{b.label.Head(), b.lext, b.rext}
// 	slots := self.nt_slot_entries[nts]
// 	slots1 := make([]BSR, 0, len(slots))
// 	bi := -1
// 	for i, s := range slots {
// 		if s == b && bi != -1 {
// 			panic(fmt.Sprintf("Duplicate slot entries: %d and %d", bi, i))
// 		} else {
// 			slots1 = append(slots1, s)
// 		}
// 	}
// 	self.nt_slot_entries[nts] = slots1
// }

// // LeftExtent returns the left extent of the BSR
// func (b BSR) LeftExtent() int {
// 	return b.lext
// }

// // RightExtent returns the right extent of the BSR
// func (b BSR) RightExtent() int {
// 	return b.rext
// }

// // Pivot returns the pivot of the BSR
// func (b BSR) Pivot() int {
// 	return b.pivot
// }

// func (b BSR) String() string {
// 	return fmt.Sprintf("%s,%d,%d,%d - %s", b.label, b.lext, b.pivot, b.rext,
// 		self.lex.GetString(b.LeftExtent(), b.RightExtent()-1))
// }

// func (s StrBSR) LeftExtent() int {
// 	return s.lext
// }

// func (s StrBSR) RightExtent() int {
// 	return s.rext
// }

// func (s StrBSR) Pivot() int {
// 	return s.pivot
// }

// func (s StrBSR) Empty() bool {
// 	return s.lext == s.pivot && s.pivot == s.rext
// }

// // String returns a string representation of s
// func (s StrBSR) String() string {
// 	// fmt.Printf("bsr.StrBSR.StrBSR(): %s, %d, %d, %d\n",
// 	// 	s.label.symbols(), s.lext, s.pivot, s.rext)
// 	ss := s.label.symbols()[:s.Label.Pos()].Strings()
// 	str := strings.Join(ss, " ")
// 	return fmt.Sprintf("%s,%d,%d,%d - %s", str, s.lext, s.pivot,
// 		s.rext, s.set.lex.GetString(s.LeftExtent(), s.RightExtent()))
// }

// func (s *Set) fail(b BSR, format string, a ...interface{}) {
// 	msg := fmt.Sprintf(format, a...)
// 	line, col := s.getLineColumn(b.LeftExtent())
// 	panic(fmt.Sprintf("Error in BSR: %s at line %d col %d\n", msg, line, col))
// }

// func decodeRune(str []byte) (string, rune, int) {
// 	if len(str) == 0 {
// 		return "$", '$', 0
// 	}
// 	r, sz := utf8.DecodeRune(str)
// 	if r == utf8.RuneError {
// 		panic(fmt.Sprintf("Rune error: %s", str))
// 	}
// 	switch r {
// 	case '\t', ' ':
// 		return "space", r, sz
// 	case '\n':
// 		return "\\n", r, sz
// 	}
// 	return string(str[:sz]), r, sz
// }

// // ReportAmbiguous lists the ambiguous subtrees of the parse forest
// func (s *Set) ReportAmbiguous() {
// 	fmt.Println("Ambiguous BSR Subtrees:")
// 	rts := s.GetRoots()
// 	if len(rts) != 1 {
// 		fmt.Printf("BSR has %d ambigous roots\n", len(rts))
// 	}
// 	for i, b := range s.GetRoots() {
// 		fmt.Println("In root", i)
// 		if !s.report(b) {
// 			fmt.Println("No ambiguous BSRs")
// 		}
// 	}
// }

// // report return true iff at least one ambigous BSR was found
// func (s *Set) report(b BSR) bool {
// 	ambiguous := false
// 	for i, sym := range b.label.symbols() {
// 		ln, col := s.getLineColumn(b.LeftExtent())
// 		if sym.IsNonTerminal() {
// 			if len(b.get_nt_children_i(i)) != 1 {
// 				ambiguous = true
// 				fmt.Printf("  Ambigous: in %s: NT %s (%d) at line %d col %d \n",
// 					b, sym, i, ln, col)
// 				fmt.Println("   Children:")
// 				for _, c := range b.get_nt_children_i(i) {
// 					fmt.Printf("     %s\n", c)
// 				}
// 			}
// 			for _, b1 := range b.get_nt_children_i(i) {
// 				s.report(b1)
// 			}
// 		}
// 	}
// 	return ambiguous
// }

`
