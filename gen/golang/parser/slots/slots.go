package slots

import (
	"bytes"
	"fmt"
	"gogll/ast"
	"gogll/frstflw"
	"gogll/goutil/ioutil"
	"gogll/gslot"
	"text/template"
)

func Gen(slotFile string, g *ast.Grammar, gs *gslot.GSlot, ff *frstflw.FF) {
	tmpl, err := template.New("Slot").Parse(slotTmpl)
	if err != nil {
		panic(err)
	}
	buf, data := new(bytes.Buffer), getData(g, gs, ff)
	if err = tmpl.Execute(buf, data); err != nil {
		panic(err)
	}
	if err := ioutil.WriteFile(slotFile, buf.Bytes()); err != nil {
		panic(err)
	}
}

type Data struct {
	Slots []*SlotData
	Alts  []*AltData
}

type AltData struct {
	NT     string
	Labels string
}

type SlotData struct {
	Label   string
	NT      string
	Alt     int
	Pos     int
	Symbols string
}

func getData(g *ast.Grammar, gs *gslot.GSlot, ff *frstflw.FF) *Data {
	return &Data{
		Slots: getSlotData(gs),
		Alts:  getAltData(g, gs, ff),
	}
}

func getAltData(g *ast.Grammar, gs *gslot.GSlot, ff *frstflw.FF) (data []*AltData) {
	for _, r := range g.Rules {
		d := &AltData{r.Head.NT, getLabelList(r, g, gs, ff)}
		data = append(data, d)
	}
	return
}

func getLabelList(rule *ast.Rule, g *ast.Grammar, gs *gslot.GSlot, ff *frstflw.FF) string {
	buf := new(bytes.Buffer)
	for i, _ := range rule.Alternates {
		if i > 0 {
			buf.WriteString(",")
		}
		buf.WriteString(gslot.NewLabel(rule.Head.NT, i, 0, gs, ff).Label())
	}
	return buf.String()
}

func getSlotData(gs *gslot.GSlot) (data []*SlotData) {
	for _, s := range gs.Slots() {
		d := &SlotData{
			Label:   s.Label(),
			NT:      s.Head,
			Alt:     s.Alternate,
			Pos:     s.Pos,
			Symbols: getSymbolList(s.Symbols()),
		}
		data = append(data, d)
	}
	return
}

func getSymbolList(ss []string) string {
	buf := new(bytes.Buffer)
	for i, s := range ss {
		if i > 0 {
			buf.WriteString(",")
		}
		fmt.Fprintf(buf, "`%s`", s)
	}
	return buf.String()
}

const slotTmpl = `
/* 
Package slot is generated by gogll. Do not edit. 
*/
package slot

import(
	"bytes"
	"fmt"
)

type Label int

type Slot struct {
	NT      string
	Alt     int
	Pos     int
	Symbols []string
	Label 	Label
}

type Index struct {
	NT      string
	Alt     int
	Pos     int
}

func GetAlternates(nt string) []Label {
	alts, exist := alternates[nt]
	if !exist {
		panic(fmt.Sprintf("Invalid NT %s", nt))
	}
	return alts
}

func GetLabel(nt string, alt, pos int) Label {
	l, exist := slotIndex[Index{nt,alt,pos}]
	if exist {
		return l
	}
	panic(fmt.Sprintf("Error: no slot label for NT=%s, alt=%d, pos=%d", nt, alt, pos))
}

func (l Label) EoR() bool {
	return l.Slot().EoR()
}

func (l Label) Head() string {
	return l.Slot().NT
}

func (l Label) Index() Index {
	s := l.Slot()
	return Index{s.NT, s.Alt, s.Pos}
}

func (l Label) Alternate() int {
	return l.Slot().Alt
}

func (l Label) Pos() int {
	return l.Slot().Pos
}

func (l Label) Slot() *Slot {
	s, exist := slots[l]
	if !exist {
		panic(fmt.Sprintf("Invalid slot label %d", l))
	}
	return s
}

func (l Label) String() string {
	return l.Slot().String()
}

func (l Label) Symbols() []string {
	return l.Slot().Symbols
}

func (s *Slot) EoR() bool {
	return s.Pos >= len(s.Symbols)
}

func (s *Slot) String() string {
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "%s : ", s.NT)
	for i, sym := range s.Symbols {
		if i == s.Pos {
			fmt.Fprintf(buf, "∙")
		}
		fmt.Fprintf(buf, "%s ", sym)
	}
	if s.Pos >= len(s.Symbols) {
		fmt.Fprintf(buf, "∙")
	}
	return buf.String()
}

const({{range $i, $l := .Slots}}
	{{$l.Label}}{{if not $i}} Label = iota{{end}}{{end}}
)

var slots = map[Label]*Slot{ {{range $i, $s := .Slots}}
	{{$s.Label}}:&Slot{"{{$s.NT}}", {{$s.Alt}}, {{$s.Pos}}, []string{ {{$s.Symbols}} }, {{$s.Label}} },{{end}}
}

var slotIndex = map[Index]Label { {{range $i, $s := .Slots}}
	Index{ "{{$s.NT}}",{{$s.Alt}},{{$s.Pos}} }: {{$s.Label}},{{end}}
}

var alternates = map[string][]Label{ {{range $i, $a := .Alts}}
	"{{$a.NT}}":[]Label{ {{$a.Labels}} },{{end}}
}

`
