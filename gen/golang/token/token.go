package token

import (
	"bytes"
	"fmt"
	"path/filepath"
	"sort"
	"text/template"

	"github.com/goccmack/gogll/ast"
	"github.com/goccmack/gogll/cfg"
	"github.com/goccmack/goutil/ioutil"
)

func Gen(g *ast.GoGLL) {
	tmpl, err := template.New("Token").Parse(tmplSrc)
	if err != nil {
		panic(err)
	}
	buf := new(bytes.Buffer)
	err = tmpl.Execute(buf, getSortedTokens(g))
	if err != nil {
		panic(err)
	}
	if err = ioutil.WriteFile(tokenFile(g.Package.GetString()), buf.Bytes()); err != nil {
		panic(err)
	}
}

func GetTokenMap(g *ast.GoGLL) map[string]string {
	tokmap := map[string]string{
		"Error": "Error",
		"EOF":   "EOF",
	}
	for i, tok := range getSortedTokens(g) {
		tokmap[tok] = fmt.Sprintf("Type%d", i)
	}
	return tokmap
}

func getSortedTokens(g *ast.GoGLL) (tokens []string) {
	for _, t := range g.Terminals.Elements() {
		tokens = append(tokens, t)
	}
	sort.Slice(tokens, func(i, j int) bool {
		return tokens[i] < tokens[j]
	})
	return
}

func tokenFile(pkg string) string {
	return filepath.Join(cfg.BaseDir, "token", "token.go")
}

const tmplSrc = `
/*
Generated by GoGLL. Do not edit
*/

package token

import(
    "fmt"
)

// Token is returned by the lexer for every scanned lexical token
type Token struct {
    Type Type
    Lext, Rext int
    Literal []rune
}

// Type is the token type
type Type = int
const(
    Error Type = iota
    EOF {{range $i, $tok := .}}
    Type{{$i}} // {{$tok}}{{end}}
)

var TypeToString = []string{
    "Error",
    "EOF", {{range $tok := .}}
    "{{$tok}}",{{end}}
}

var StringToType = map[string] int {
    "Error": Error,
    "EOF": EOF, {{range $i, $tok := .}}
    "{{$tok}}": Type{{$i}},{{end}}
}

func New(t Type, lext, rext int, lit []rune) *Token {
    return &Token{
        Type: t,
        Lext: lext,
        Rext: rext,
        Literal: lit,
    }
}

func (t *Token) CharValue() rune {
	if t.Literal[1] != '\\' {
		return t.Literal[1]
	}
	switch t.Literal[2] {
	case '\\':
		return '\\'
	case '\'':
		return '\''
	case 'n':
		return '\n'
	case 'r':
		return '\r'
	case 't':
		return '\t'
	}
	panic(fmt.Sprintf("invalid escaped char: %s", string(t.Literal)))
}

func (t *Token) String() string {
	return fmt.Sprintf("%s (%d,%d) %s",
		TypeToString[t.Type], t.Lext, t.Rext, string(t.Literal))
}
`
