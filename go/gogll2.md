# Gogll2

# Scannerless Generalised LL Parsing
Gogll generates scannerless *generalised LL parsers*[1], specifically clustered nonterminal BSR parsers (CNP) [2].

# Walking the Parse Forest
Gogll produces a parse forest represented by a set of Binary Subtree Representations. See [BSR](bsr.md) for details of walking the parse forest.

# Input Symbols, Markdown Files
Gogll accepts UTF-8 input strings. 
A gogll parser has two parse functions: 
* `Parse(I []byte) []*ParseError`
* `func ParseFile(fname string) []*ParseError`   
If `fname` ends with `.md` the parser ignores all text outside the markdown code blocks delimited by triple backticks. 

This document contains BNF specification for gogll V2, which is is generated by gogll. 

The markdown code block below specifies the input symbols used in gogll production rules.

```
Symbol 
    :   "any"
    |   "anyof" Space String
    |   "letter"
    |   "number"
    |   "space"
    |   "upcase"
    |   "lowcase"
    |   "not" String
    |   CharLiteral 
    ;
```
* `any` accepts any character  
* `anyof String` accepts any character that is an element of `String`  
* `letter` accepts any character from the Unicode letter category  
* `number` accepts any character from the Unicode number category  
* `space` accepts any Unicode white space character
* `upcase` accepts any upper case letter
* `lowcase` accepts any lower case letter
* `not "String"` accepts any character that is not an element of `String`

```
CharLiteral 
    :   "'" "\\" EscapedChar "'"
    |   "'" any "'"
    ;
```

Examples:

    'n'
    '\r'

EscapedChar : "\"" | "n" | "r" | "t" | "\\" ;

String : "\"" StringChars "\"" ;

StringChars
    :   not Space "\""
    |   emptyAlt
    ;

Space
    :   space
    |   space Space
    ;
```

# References
1. Elizabeth Scott and Adrian Johnstone,
*GLL Parsing*,
Electronic Notes in Theoretical Computer Science 253 (2010) 177–189 

2. Elizabeth Scott, Adrian Johnstone and L. Thomas van Binsbergen,
*Derivation representation using binary subtree sets*,
Science of Computer Programming 175 (2019) 63–84