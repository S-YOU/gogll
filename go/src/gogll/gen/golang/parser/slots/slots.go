package slots

import (
	"bytes"
	"fmt"
	"gogll/ast"
	"gogll/goutil/ioutil"
	"gogll/gslot"
	"text/template"
)

func Gen(slotFile string) {
	tmpl, err := template.New("Slot").Parse(slotTmpl)
	if err != nil {
		panic(err)
	}
	buf, data := new(bytes.Buffer), getData()
	if err = tmpl.Execute(buf, data); err != nil {
		panic(err)
	}
	if err := ioutil.WriteFile(slotFile, buf.Bytes()); err != nil {
		panic(err)
	}
}

type Data struct {
	Slots []*SlotData
	Alts  []*AltData
}

type AltData struct {
	NT     string
	Labels string
}

type SlotData struct {
	Label   string
	NT      string
	Alt     int
	Pos     int
	Symbols string
}

func getData() *Data {
	return &Data{
		Slots: getSlotData(),
		Alts:  getAltData(),
	}
}

func getAltData() (data []*AltData) {
	for nt, r := range ast.GetRules() {
		d := &AltData{nt, getLabelList(r)}
		data = append(data, d)
	}
	return
}

func getLabelList(rule *ast.Rule) string {
	buf := new(bytes.Buffer)
	for i, _ := range rule.Alternates {
		if i > 0 {
			buf.WriteString(",")
		}
		buf.WriteString(gslot.Label{rule.Head.Value(), i, 0}.Label())
	}
	return buf.String()
}

func getSlotData() (data []*SlotData) {
	for _, s := range gslot.GetSlots() {
		d := &SlotData{
			Label:   s.Label(),
			NT:      s.Head,
			Alt:     s.Alternate,
			Pos:     s.Pos,
			Symbols: getSymbolList(s.Symbols()),
		}
		data = append(data, d)
	}
	return
}

func getSymbolList(ss []string) string {
	buf := new(bytes.Buffer)
	for i, s := range ss {
		if i > 0 {
			buf.WriteString(",")
		}
		fmt.Fprintf(buf, "\"%s\"", s)
	}
	return buf.String()
}

const slotTmpl = `
/* 
Package slot is generated by gogll. Do not edit. 
*/
package slot

import(
	"bytes"
	"fmt"
)

type Label int

const({{range $i, $l := .Slots}}
	{{$l.Label}}{{if not $i}} = iota{{end}}{{end}}
)

type Slot struct {
	NT      string
	Alt     int
	Pos     int
	Symbols []string
}

var slots = map[Label]*Slot{ {{range $i, $s := .Slots}}
	{{$s.Label}}:&Slot{"{{$s.NT}}", {{$s.Alt}}, {{$s.Pos}}, []string{ {{$s.Symbols}} } }, {{end}}
}

var alternates = map[string][]Label{ {{range $i, $a := .Alts}}
	"{{$a.NT}}":[]Label{ {{$a.Labels}} },{{end}}
}

func GetAlternates(nt string) []Label {
	alts, exist := alternates[nt]
	if !exist {
		panic(fmt.Sprintf("Invalid NT %s", nt))
	}
	return alts
}

func (l Label) EoR() bool {
	return l.Slot().EoR()
}

func (l Label) Pos() int {
	return l.Slot().Pos
}

func (l Label) Slot() *Slot {
	s, exist := slots[l]
	if !exist {
		panic(fmt.Sprintf("Invalid slot label %d", l))
	}
	return s
}

func (l Label) String() string {
	return l.Slot().String()
}

func (l Label) Symbols() []string {
	return l.Slot().Symbols
}

func (s *Slot) EoR() bool {
	return s.Pos >= len(s.Symbols)
}

func (s *Slot) String() string {
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "%s : ", s.NT)
	for i, sym := range s.Symbols {
		if i == s.Pos {
			fmt.Fprintf(buf, "∙")
		}
		fmt.Fprintf(buf, "%s ", sym)
	}
	if s.Pos >= len(s.Symbols) {
		fmt.Fprintf(buf, "∙")
	}
	return buf.String()
}

`
