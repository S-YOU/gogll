package bsr

import (
	"bytes"
	"gogll/cfg"
	"gogll/goutil/ioutil"
	"html/template"
)

func Gen(bsrFile string) {
	tmpl, err := template.New("BSR").Parse(bsrTmpl)
	if err != nil {
		panic(err)
	}
	buf := new(bytes.Buffer)
	if err = tmpl.Execute(buf, cfg.Package); err != nil {
		panic(err)
	}
	if err = ioutil.WriteFile(bsrFile, buf.Bytes()); err != nil {
		panic(err)
	}
}

const bsrTmpl = `/*
Package bsr is generated by gogll. Do not edit.
It implements a Binary Subtree Representation set as defined in

	Scott et al
	Derivation representation using binary subtree sets,
	Science of Computer Programming 175 (2019)

*/
package bsr

import (
	"{{.}}/parser/slot"
)

type BSR interface {
	LeftExtent() int
	RightExtent() int
	InputPos() int
}

var Set = newSet()

type BSRSet struct {
	slotEntries   map[Slot]bool
	stringEntries map[String]bool
}

type Slot struct {
	Label       slot.Label
	leftExtent  int
	inputPos    int
	rightExtent int
}

type String struct {
	Label slot.Label
	leftExtent  int
	inputPos    int
	rightExtent int
}

func newSet() *BSRSet {
	return &BSRSet{
		slotEntries:   make(map[Slot]bool),
		stringEntries: make(map[String]bool),
	}
}

/*
Add a BSR to the set. (i,j) is the extent. k is the pivot.
*/
func Add(l slot.Label, i, k, j int) {
	if l.EoR() {
		insert(Slot{l, i, k, j})
	} else {
		if l.Pos() > 0 {
			insert(String{l, i, k, j})
		}
	}
}

func AddEmpty(l slot.Label, i int) {
	insert(&String{l, i, i, i})
}

func Contain(nt string, left, right int) bool {
	for e, _ := range Set.stringEntries {
		if e.Label.Slot().NT == nt && e.LeftExtent() == left && e.RightExtent() == right {
			return true
		}
	}
	return false
}

func insert(bsr BSR) {
	switch s := bsr.(type) {
	case Slot:
		Set.slotEntries[s] = true
	case String:
		Set.stringEntries[s] = true
	}
	panic("must not happen")
}

func (s Slot) LeftExtent() int {
	return s.leftExtent
}

func (s Slot) RightExtent() int {
	return s.rightExtent
}

func (s Slot) InputPos() int {
	return s.inputPos
}

func (s String) LeftExtent() int {
	return s.leftExtent
}

func (s String) RightExtent() int {
	return s.rightExtent
}

func (s String) InputPos() int {
	return s.inputPos
}

func (s String) Empty() bool {
	return s.leftExtent == s.inputPos && s.inputPos == s.rightExtent
}
`
