package bsr

import (
	"bytes"
	"gogll/cfg"
	"gogll/goutil/ioutil"
	"text/template"
)

func Gen(bsrFile string) {
	tmpl, err := template.New("BSR").Parse(bsrTmpl)
	if err != nil {
		panic(err)
	}
	buf := new(bytes.Buffer)
	if err = tmpl.Execute(buf, cfg.Package); err != nil {
		panic(err)
	}
	if err = ioutil.WriteFile(bsrFile, buf.Bytes()); err != nil {
		panic(err)
	}
}

const bsrTmpl = `/*
Package bsr is generated by gogll. Do not edit.

Copyright Marius Ackerman 2019

It implements a Binary Subtree Representation set as defined in

	Scott et al
	Derivation representation using binary subtree sets,
	Science of Computer Programming 175 (2019)

*/
package bsr

import (
	"fmt"
	"os"
	"sort"
	"strings"

	"ql/parser/slot"
)

type BSR interface {
	LeftExtent() int
	RightExtent() int
	Pivot() int
}

var (
	set = newSet()
	startSym string
)

type BSRSet struct {
	slotEntries   map[Slot]bool
	stringEntries map[String]bool
	rightExtent   int
}

type Slot struct {
	Label       slot.Label
	leftExtent  int
	pivot       int
	rightExtent int
}

type String struct {
	Label       slot.Label
	leftExtent  int
	pivot       int
	rightExtent int
}

func newSet() *BSRSet {
	return &BSRSet{
		slotEntries:   make(map[Slot]bool),
		stringEntries: make(map[String]bool),
	}
}

/*
Add a BSR to the set. (i,j) is the extent. k is the pivot.
*/
func Add(l slot.Label, i, k, j int) {
	// fmt.Printf("bsr.Add(%s,%d,%d,%d)\n", l,i,k,j)
	if l.EoR() {
		insert(Slot{l, i, k, j})
	} else {
		if l.Pos() > 1 {
			insert(String{l, i, k, j})
		}
	}
}

func AddEmpty(l slot.Label, i int) {
	insert(String{l, i, i, i})
}

func Contain(nt string, left, right int) bool {
	// fmt.Printf("bsr.Contain(%s,%d,%d)\n",nt,left,right)
	for e, _ := range set.slotEntries {
		// fmt.Printf("  (%s,%d,%d)\n",e.Label.Head(),e.leftExtent,e.rightExtent)
		if e.Label.Head() == nt && e.leftExtent == left && e.rightExtent == right {
			// fmt.Println("  true")
			return true
		}
	}
	// fmt.Println("  false")
	return false
}

func GetBSRs() (bsrs []BSR) {
	bsrs = make([]BSR, 0, len(set.slotEntries)+len(set.stringEntries))
	for s, _ := range set.slotEntries {
		bsrs = append(bsrs, s)
	}
	for s, _ := range set.stringEntries {
		bsrs = append(bsrs, s)
	}
	sort.Slice(bsrs, func(i, j int) bool {
		iw := bsrs[i].RightExtent() - bsrs[i].LeftExtent()
		jw := bsrs[j].RightExtent() - bsrs[j].LeftExtent()
		if iw > jw {
			return true
		}
		if iw == jw {
			return bsrs[i].Pivot() > bsrs[j].Pivot()
		}
		return false
	})
	return
}

func GetNTSlot(nt string, leftExtent, rightExtent int) Slot {
	for sl, _ := range set.slotEntries {
		if sl.Label.Head() == nt && sl.leftExtent == leftExtent && sl.rightExtent == rightExtent {
			return sl
		}
	}
	fmt.Printf("No Slot %s left extent=%d right extent=%d\n", nt, leftExtent, rightExtent)
	panic("")
	// os.Exit(1)
}

func GetRightExtent() int {
	return set.rightExtent
}

func GetRoot() (roots []Slot) {
	for s, _ := range set.slotEntries {
		if s.Label.Head() == startSym && s.leftExtent == 0 && s.rightExtent == set.rightExtent {
			roots = append(roots, s)
		}
	}
	return
}

func GetString(l slot.Label, leftExtent, rightExtent int) String {
	for str, _ := range set.stringEntries {
		if str.Label == l && str.leftExtent == leftExtent && str.rightExtent == rightExtent {
			return str
		}
	}
	fmt.Printf("Error: no string %s left extent=%d right extent=%d pos=%d\n",
		strings.Join(l.Symbols()[:l.Pos()], " "), leftExtent, rightExtent, l.Pos())
	panic("must not happen")
}

func Init(startSymbol string) {
	set = newSet()
	startSym = startSymbol
}

func insert(bsr BSR) {
	if bsr.RightExtent() > set.rightExtent {
		set.rightExtent = bsr.RightExtent()
	}
	switch s := bsr.(type) {
	case Slot:
		set.slotEntries[s] = true
	case String:
		set.stringEntries[s] = true
	default:
		panic(fmt.Sprintf("Invalid type %T", bsr))
	}
}

func (s Slot) GetNTChild(nt string) Slot {
	symbols, i := s.Label.Symbols(), 0
	for ; i < len(symbols) && symbols[i] != nt; i++ {
	}
	if i >= len(symbols) {
		fmt.Printf("Error: %s has no NT %s\n", s, nt)
		os.Exit(1)
	}

	if i >= len(s.Label.Symbols()) {
		fmt.Printf("Error: cannot get NT child %d of %s\n", i, s)
		os.Exit(1)
	}
	idx := s.Label.Index()
	str := String{s.Label, s.leftExtent, s.pivot, s.rightExtent}
	for idx.Pos > i+1 {
		idx.Pos--
		str = GetString(slot.GetLabel(idx.NT, idx.Alt, idx.Pos), str.leftExtent, str.pivot)
	}
	return GetNTSlot(s.Label.Symbols()[i], str.pivot, str.rightExtent)
}

func (s Slot) LeftExtent() int {
	return s.leftExtent
}

func (s Slot) RightExtent() int {
	return s.rightExtent
}

func (s Slot) Pivot() int {
	return s.pivot
}

func (s Slot) String() string {
	return fmt.Sprintf("%s,%d,%d,%d", s.Label, s.leftExtent, s.pivot, s.rightExtent)
}

func (s String) LeftExtent() int {
	return s.leftExtent
}

func (s String) RightExtent() int {
	return s.rightExtent
}

func (s String) Pivot() int {
	return s.pivot
}

func (s String) Empty() bool {
	return s.leftExtent == s.pivot && s.pivot == s.rightExtent
}

func (s String) String() string {
	// fmt.Printf("bsr.String.String(): %s, %d, %d, %d\n",
	// 	s.Label.Symbols(), s.leftExtent, s.pivot, s.rightExtent)
	ss := s.Label.Symbols()[:s.Label.Pos()]
	str := strings.Join(ss, " ")
	return fmt.Sprintf("%s,%d,%d,%d", str, s.leftExtent, s.pivot,
		s.rightExtent)
}

func Dump() {
	DumpSlots()
	DumpStrings()
}

func DumpSlots() {
	fmt.Printf("Slots (%d)\n", len(GetSlots()))
	for _, s := range GetSlots() {
		DumpSlot(s)
	}
}

func DumpSlot(s Slot) {
	fmt.Println(s)
}

func DumpStrings() {
	fmt.Printf("Strings(%d)\n", len(GetStrings()))
	for _, s := range GetStrings() {
		DumpString(s)
	}
}

func DumpString(s String) {
	fmt.Println(s)
}

func GetSlots() (slots []Slot) {
	for s := range set.slotEntries {
		slots = append(slots, s)
	}
	sort.Slice(slots,
		func(i, j int) bool {
			return slots[i].Label < slots[j].Label
		})
	return
}

func GetStrings() (strings []String) {
	for s := range set.stringEntries {
		strings = append(strings, s)
	}
	sort.Slice(strings,
		func(i, j int) bool {
			return strings[i].Label < strings[j].Label
		})
	return
}
`
