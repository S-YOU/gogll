package bsr

import (
	"bytes"
	"gogll/cfg"
	"gogll/goutil/ioutil"
	"text/template"
)

func Gen(bsrFile string) {
	tmpl, err := template.New("bsr").Parse(bsrTmpl)
	if err != nil {
		panic(err)
	}
	buf := new(bytes.Buffer)
	if err = tmpl.Execute(buf, cfg.Package); err != nil {
		panic(err)
	}
	if err = ioutil.WriteFile(bsrFile, buf.Bytes()); err != nil {
		panic(err)
	}
}

const bsrTmpl = `/*
Package bsr is generated by gogll. Do not edit.

Copyright Marius Ackerman 2019

It implements a Binary Subtree Representation set as defined in

	Scott et al
	Derivation representation using binary subtree sets,
	Science of Computer Programming 175 (2019)

*/
package bsr

import (
	"fmt"
	"os"
	"sort"
	"strings"

	"ql/parser/slot"
)

type bsr interface {
	LeftExtent() int
	RightExtent() int
	Pivot() int
}

var (
	set = newSet()
	startSym string
)

type bsrSet struct {
	slotEntries   map[BSR]bool
	stringEntries map[stringBSR]bool
	rightExtent   int
}

// BSR is the binary subtree representation of a parsed nonterminal
type BSR struct {
	Label       slot.Label
	leftExtent  int
	pivot       int
	rightExtent int
}

type stringBSR struct {
	Label       slot.Label
	leftExtent  int
	pivot       int
	rightExtent int
}

func newSet() *bsrSet {
	return &bsrSet{
		slotEntries:   make(map[BSR]bool),
		stringEntries: make(map[stringBSR]bool),
	}
}

/*
Add a bsr to the set. (i,j) is the extent. k is the pivot.
*/
func Add(l slot.Label, i, k, j int) {
	// fmt.Printf("bsr.Add(%s,%d,%d,%d)\n", l,i,k,j)
	if l.EoR() {
		insert(BSR{l, i, k, j})
	} else {
		if l.Pos() > 1 {
			insert(stringBSR{l, i, k, j})
		}
	}
}

func AddEmpty(l slot.Label, i int) {
	insert(stringBSR{l, i, i, i})
}

func Contain(nt string, left, right int) bool {
	// fmt.Printf("bsr.Contain(%s,%d,%d)\n",nt,left,right)
	for e, _ := range set.slotEntries {
		// fmt.Printf("  (%s,%d,%d)\n",e.Label.Head(),e.leftExtent,e.rightExtent)
		if e.Label.Head() == nt && e.leftExtent == left && e.rightExtent == right {
			// fmt.Println("  true")
			return true
		}
	}
	// fmt.Println("  false")
	return false
}

// GetRightExtent returns the right extent of the BSR set
func GetRightExtent() int {
	return set.rightExtent
}

func GetRoot() (roots []BSR) {
	for s, _ := range set.slotEntries {
		if s.Label.Head() == startSym && s.leftExtent == 0 && s.rightExtent == set.rightExtent {
			roots = append(roots, s)
		}
	}
	return
}

func getString(l slot.Label, leftExtent, rightExtent int) stringBSR {
	for str, _ := range set.stringEntries {
		if str.Label == l && str.leftExtent == leftExtent && str.rightExtent == rightExtent {
			return str
		}
	}
	fmt.Printf("Error: no string %s left extent=%d right extent=%d pos=%d\n",
		strings.Join(l.Symbols()[:l.Pos()], " "), leftExtent, rightExtent, l.Pos())
	panic("must not happen")
}

func Init(startSymbol string) {
	set = newSet()
	startSym = startSymbol
}

func insert(bsr bsr) {
	if bsr.RightExtent() > set.rightExtent {
		set.rightExtent = bsr.RightExtent()
	}
	switch s := bsr.(type) {
	case BSR:
		set.slotEntries[s] = true
	case stringBSR:
		set.stringEntries[s] = true
	default:
		panic(fmt.Sprintf("Invalid type %T", bsr))
	}
}

// Alternate returns the index of the grammar rule alternate.
func (b BSR) Alternate() int {
	return b.Label.Alternate()
}

func (s BSR) GetNTChild(nt string) BSR {
	symbols, i := s.Label.Symbols(), 0
	for ; i < len(symbols) && symbols[i] != nt; i++ {
	}
	if i >= len(symbols) {
		fmt.Printf("Error: %s has no NT %s\n", s, nt)
		os.Exit(1)
	}

	if i >= len(s.Label.Symbols()) {
		fmt.Printf("Error: cannot get NT child %d of %s\n", i, s)
		os.Exit(1)
	}
	idx := s.Label.Index()
	str := stringBSR{s.Label, s.leftExtent, s.pivot, s.rightExtent}
	for idx.Pos > i+1 {
		idx.Pos--
		str = getString(slot.GetLabel(idx.NT, idx.Alt, idx.Pos), str.leftExtent, str.pivot)
	}
	return getNTSlot(s.Label.Symbols()[i], str.pivot, str.rightExtent)
}

func (s BSR) LeftExtent() int {
	return s.leftExtent
}

func (s BSR) RightExtent() int {
	return s.rightExtent
}

func (s BSR) Pivot() int {
	return s.pivot
}

func (s BSR) stringBSR() string {
	return fmt.Sprintf("%s,%d,%d,%d", s.Label, s.leftExtent, s.pivot, s.rightExtent)
}

func (s stringBSR) LeftExtent() int {
	return s.leftExtent
}

func (s stringBSR) RightExtent() int {
	return s.rightExtent
}

func (s stringBSR) Pivot() int {
	return s.pivot
}

func (s stringBSR) Empty() bool {
	return s.leftExtent == s.pivot && s.pivot == s.rightExtent
}

func (s stringBSR) stringBSR() string {
	// fmt.Printf("bsr.stringBSR.stringBSR(): %s, %d, %d, %d\n",
	// 	s.Label.Symbols(), s.leftExtent, s.pivot, s.rightExtent)
	ss := s.Label.Symbols()[:s.Label.Pos()]
	str := strings.Join(ss, " ")
	return fmt.Sprintf("%s,%d,%d,%d", str, s.leftExtent, s.pivot,
		s.rightExtent)
}

func Dump() {
	DumpSlots()
	DumpStrings()
}

func DumpSlots() {
	fmt.Printf("Slots (%d)\n", len(getSlots()))
	for _, s := range getSlots() {
		DumpSlot(s)
	}
}

func DumpSlot(s BSR) {
	fmt.Println(s)
}

func DumpStrings() {
	fmt.Printf("Strings(%d)\n", len(getStrings()))
	for _, s := range getStrings() {
		dumpString(s)
	}
}

func dumpString(s stringBSR) {
	fmt.Println(s)
}

func getSlots() (slots []BSR) {
	for s := range set.slotEntries {
		slots = append(slots, s)
	}
	sort.Slice(slots,
		func(i, j int) bool {
			return slots[i].Label < slots[j].Label
		})
	return
}

func getStrings() (strings []stringBSR) {
	for s := range set.stringEntries {
		strings = append(strings, s)
	}
	sort.Slice(strings,
		func(i, j int) bool {
			return strings[i].Label < strings[j].Label
		})
	return
}

func getNTSlot(nt string, leftExtent, rightExtent int) BSR {
	for sl, _ := range set.slotEntries {
		if sl.Label.Head() == nt && sl.leftExtent == leftExtent && sl.rightExtent == rightExtent {
			return sl
		}
	}
	fmt.Printf("No BSR %s left extent=%d right extent=%d\n", nt, leftExtent, rightExtent)
	panic("")
	// os.Exit(1)
}

`
