package golang

import (
	"bytes"
	"fmt"
	"gogll/ast"
	"gogll/gslot"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

const FilePerm = 0731

var g *ast.Grammar

func Gen(baseDir string, grammar *ast.Grammar) {
	genParserUtils(baseDir)
	g = grammar
	buf := new(bytes.Buffer)
	tmpl, err := template.New("Parser Template").Parse(src)
	if err != nil {
		failError(err)
	}
	if err = tmpl.Execute(buf, getData(baseDir)); err != nil {
		failError(err)
	}
	parserDir := path.Join(baseDir, "parser")
	if err := os.MkdirAll(parserDir, FilePerm); err != nil {
		failError(err)
	}
	fname := path.Join(parserDir, "parser.go")
	if err := ioutil.WriteFile(fname, buf.Bytes(), FilePerm); err != nil {
		failError(err)
	}
}

type Data struct {
	Package     string
	Imports     []string
	StartSymbol string
	Labels      []string
	Rules       []*RuleCode
}

type RuleCode struct {
	Label string
	Code  string
}

func getData(baseDir string) *Data {
	data := &Data{
		Package:     getPackage(baseDir),
		Imports:     getImports(baseDir),
		StartSymbol: ast.GetStartSymbol(),
		Rules:       getRules(),
	}
	data.Labels = getLabels(data.Rules)
	return data
}

func getImports(baseDir string) []string {
	return []string{
		"io/ioutil",
	}
}

func getLabels(ruleCode []*RuleCode) (labels []string) {
	for _, r := range ruleCode {
		labels = append(labels, r.Label)
	}
	for _, s := range gslot.GetSlots() {
		labels = append(labels, s.Label())
	}
	sort.Strings(labels)
	return
}

func getRules() (rules []*RuleCode) {
	for _, nt := range ast.GetNonTerminals() {
		rules = append(rules, getRuleCode(nt)...)
	}
	return
}

func getRuleCode(nt string) (rules []*RuleCode) {
	rule := ast.GetRule(nt)
	rules = append(rules, getRuleTestCode(rule))
	for i := range rule.Alternates {
		rules = append(rules, getAlternateCode(rule, i))
	}
	return
}

func getAlternateCode(rule *ast.Rule, altI int) *RuleCode {
	rc := &RuleCode{
		Label: getAlternateLabel(rule.Head.Value(), altI),
		Code:  codeAlt(rule, altI),
	}
	return rc
}

func getAlternateLabel(nt string, i int) string {
	return fmt.Sprintf("L_%s%d", nt, i)
}

func getRuleTestCode(rule *ast.Rule) *RuleCode {
	r := &RuleCode{
		Label: "J_" + rule.Head.Value(),
		Code:  getTestSelectsForRule(rule),
	}
	return r
}

func getTestSelectsForRule(rule *ast.Rule) (code string) {
	buf := new(bytes.Buffer)
	for i, a := range rule.Alternates {
		altCode := getTestSelectForAlternate(rule.Head.Value(), i, a.Symbols()...)
		fmt.Fprintf(buf, "%s\n", altCode)
	}
	fmt.Fprint(buf, "            L = L0\n")
	return buf.String()
}

func getPackage(baseDir string) string {
	if ast.GetPackage() == "" {
		pl := strings.Split(filepath.Clean(filepath.ToSlash(baseDir)), "/")
		pkg := pl[len(pl)-1]
		return pkg
	}
	return ast.GetPackage()
}

func failError(err error) {
	fmt.Printf("Error generating parser: %s\n", err)
	panic("fix me")
	os.Exit(1)
}

const src = `
/* 
Generated by gogll. Do not edit 
*/
package parser

import(
	"fmt"
	"os"
	"unicode/utf8"
	{{range $i, $import := .Imports}}
	"{{$import}}" {{end}}
)

const EOF rune = -1

// Rule and grammar slot labels
const (
	L0 int = iota{{range $i, $l := .Labels}}
	{{$l}}{{end}}
)

func ParseFile(fname string) {
	buf, err := ioutil.ReadFile(fname)
	if err != nil {
		failError(err)
	}
	Parse(buf)
}

func Parse(input []byte) {
	stack, forest := NewGSS(), NewSPPF()
	m := len(input)
	u0 := &GSSNode{L: L0, I: 0}
	cU, cN, cI := u0, Dummy, 0
	UR := NewDescriptors()

	L := J_{{.StartSymbol}}
	for done := false; !done; {
		next, runeSize := decodeRune(input[cI:])
		switch L {
		case L0:
			if !UR.Empty() {
				L, cU, cI, cN = UR.Remove()
			} else {
				if forest.Exist("{{.StartSymbol}}", 0, m) {
					return
				} else {
					fail()
				}
			}

		{{range $i, $r := .Rules}}case {{$r.Label}}:
			{{$r.Code}}

		{{end}}default:
			panic("This must not happen")
		}
	}
}

func decodeRune(str []byte) (string, int) {
	r, sz := utf8.DecodeRune(str)
	if r == utf8.RuneError {
		panic(fmt.Sprintf("Rune error: %s", str))
	}
	chr := runeToString(r)
	return chr, sz
}

func runeToString(r rune) string {
	buf := make([]byte, utf8.RuneLen(r))
	utf8.EncodeRune(buf, r)
	return string(buf)
}

/*** Errors ***/

func fail() {
	panic("implement me")
}

func failError(err error) {
	fmt.Printf("Error: %s\n", err)
	os.Exit(1)
}

`
