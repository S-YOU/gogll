package golang

import (
	"bytes"
	"fmt"
	"gogll/ast"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strings"
	"text/template"
)

const FilePerm = 0731

var g *ast.Grammar

func Gen(baseDir string, grammar *ast.Grammar) {
	g = grammar
	buf := new(bytes.Buffer)
	tmpl, err := template.New("Parser Template").Parse(src)
	if err != nil {
		failError(err)
	}
	if err = tmpl.Execute(buf, getData(baseDir)); err != nil {
		failError(err)
	}
	parserDir := path.Join(baseDir, "parser")
	if err := os.MkdirAll(parserDir, FilePerm); err != nil {
		failError(err)
	}
	fname := path.Join(parserDir, "parser.go")
	if err := ioutil.WriteFile(fname, buf.Bytes(), FilePerm); err != nil {
		failError(err)
	}
}

type Data struct {
	Package     string
	Imports     []string
	StartSymbol string
	Labels      []string
	Rules       []*RuleCode
}

type RuleCode struct {
	Label string
	Code  string
}

func getData(baseDir string) *Data {
	data := &Data{
		Package:     getPackage(baseDir),
		Imports:     getImports(baseDir),
		StartSymbol: ast.GetStartSymbol(),
		Rules:       getRules(),
	}
	data.Labels = getLabels(data.Rules)
	return data
}

func getImports(baseDir string) []string {
	return []string{
		"io/ioutil",
		getPackage(baseDir) + "/goutil/utf8",
	}
}

func getLabels(ruleCode []*RuleCode) (labels []string) {
	for _, r := range ruleCode {
		labels = append(labels, r.Label)
	}
	return
}

func getRules() (rules []*RuleCode) {
	for _, nt := range ast.GetNonTerminals() {
		rules = append(rules, getRuleCode(nt)...)
	}
	return
}

func getRuleCode(nt string) (rules []*RuleCode) {
	rule := ast.GetRule(nt)
	rules = append(rules, getRuleTestCode(rule))
	for i, a := range rule.Alternates {
		rules = append(rules, getAlternateCode(nt, i, a))
	}
	return
}

func getAlternateCode(nt string, i int, alt *ast.Alternate) *RuleCode {
	rc := &RuleCode{
		Label: getAlternateLabel(nt, i),
		Code:  codeAlt(nt, alt.Symbols()...),
	}
	return rc
}

func getAlternateLabel(nt string, i int) string {
	return fmt.Sprintf("L_%s%d", nt, i)
}

func getRuleTestCode(rule *ast.Rule) *RuleCode {
	r := &RuleCode{
		Label: "J_" + rule.Head.Value(),
		Code:  getTestSelectsForRule(rule),
	}
	return r
}

func getTestSelectsForRule(rule *ast.Rule) (code string) {
	buf := new(bytes.Buffer)
	for i, a := range rule.Alternates {
		altCode := getTestSelectForAlternate(rule.Head.Value(), i, a.Symbols()...)
		fmt.Fprintf(buf, "%s\n", altCode)
	}
	return buf.String()
}

func getPackage(baseDir string) string {
	if ast.GetPackage() == "" {
		pl := strings.Split(filepath.Clean(filepath.ToSlash(baseDir)), "/")
		pkg := pl[len(pl)-1]
		return pkg
	}
	return ast.GetPackage()
}

func failError(err error) {
	fmt.Printf("Error generating parser: %s\n", err)
	panic("fix me")
	os.Exit(1)
}

const src = `
/* 
Generated by gogll. Do not edit 
*/
package parser

import({{range $i, $import := .Imports}}
	"{{$import}}" {{end}}
)

const EOF rune = -1

// Rule labels
const (
	L0 int = iota{{range $i, $l := .Labels}}
	{{$l}}{{end}}
)

func ParseFile(fname string) {
	buf, err := ioutil.ReadFile(fname)
	if err != nil {
		failError(err)
	}
	Parse(buf)
}

func Parse(input []byte) {
	m := len(input)
	u0 := gss.Node{L0, 0}
	cU, cN, cI := u0, sppf.Dummy, 0
	U, R := descriptors.EmptySet()
	P := popped.EmptySet()

	label := J_{{.StartSymbol}}
	for done := false; !done; {
		next := myutf8.DecodeRune(input[cI:])
		switch label {
		case L0:
			if !R.Empty() {
				label, cU, cN, cI = R.Remove()
			} else {
				if sppf.Exist("{{.StartSymbol}}", 0, m) {
					return
				} else {
					fail()
				}
			}

		{{range $i, $r := .Rules}}case {{$r.Label}}:
			{{$r.Code}}

		{{end}}default:
			panic("This must not happen")
		}
	}
}
`
