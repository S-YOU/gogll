package sppf

import (
	"bytes"
	"fmt"
	"gogll/ast"
	"gogll/goutil/ioutil"
	"gogll/gslot"
	"path/filepath"
	"text/template"
)

func Gen(parserDir string) {
	tmpl, err := template.New("sppf").Parse(src)
	if err != nil {
		panic(err)
	}
	buf := new(bytes.Buffer)
	if err := tmpl.Execute(buf, getData()); err != nil {
		panic(err)
	}
	sppfDir := filepath.Join(parserDir, "sppf")
	sppfFile := filepath.Join(sppfDir, "sppf.go")
	if err := ioutil.WriteFile(sppfFile, buf.Bytes()); err != nil {
		panic(err)
	}
}

type Data struct {
	Package string
	Slots   []*Slot
}

type Slot struct {
	Label  string
	Head   string
	EoR    bool
	FiR    bool
	String string
}

func getData() *Data {
	data := &Data{
		Package: ast.GetPackage(),
		Slots:   getSlots(),
	}
	return data
}

func getSlots() (slots []*Slot) {
	for _, s := range gslot.GetSlots() {
		s1 := &Slot{
			Label:  s.Label(),
			Head:   s.Head,
			EoR:    s.IsEoR(),
			FiR:    s.IsFiR(),
			String: fmt.Sprintf("`%s`", s.String()),
		}
		slots = append(slots, s1)
	}
	return
}

const src = `
/*
Packge sppf is generated by gogll. Do not edit.
Package sppf implements a binarised shared packed parse forest
*/
package sppf

import(
	"fmt"
	
	"{{.Package}}/parser/labels"
)

// Empty denotes the empty string. It is represented by the character, 'ϵ'
const Empty = "ϵ"

var (
	intermediateNodes = make(map[InKey]*IntermediateNode)
	packedNodes       = make(map[PNKey]*PackedNode)
	symbolNodes       = make(map[SNKey]*SymbolNode)
	// Key=slot label
	slots = map[int]*GrammarSlot{ {{range $i, $s := .Slots}}
		labels.{{$s.Label}}: &GrammarSlot{
						Head: "{{$s.Head}}",
						EoR: {{$s.EoR}},
						FiR: {{$s.FiR}},
						String: {{$s.String}},
					  },{{end}}
	}
)

func GetIntermediateNodes() (nds []*IntermediateNode) {
	for _, nd := range intermediateNodes {
		nds = append(nds, nd)
	}
	return
}

func GetPackedNodes() (nds []*PackedNode) {
	for _, nd := range packedNodes {
		nds = append(nds, nd)
	}
	return
}

func GetSymbolNodes() (nds []*SymbolNode) {
	for _, nd := range symbolNodes {
		nds = append(nds, nd)
	}
	return
}

type GrammarSlot struct {
	Head   string
	Body   []string
	FiR    bool
	EoR    bool
	String string
}

type Node interface {
	Equal(Node) bool
	GetExtent() (left, right int)
	GetLeftExtent() int
	GetRightExtent() int
	DotLabel() string
	HasChild(L int, k int) bool
	SetChild(Node)
}

type Extent struct {
	Left  int
	Right int
}

var Dummy Node = (*SymbolNode)(nil)

type Edge struct {
	from, to Node
}

func ExistSymNode(sym string, left, right int) bool {
	snk := &SNKey{
		Symbol: sym,
		Extent: Extent{
			Left:  left,
			Right: right,
		},
	}
	_, exist := symbolNodes[*snk]
	return exist
}

/*
GetNode returns an SPPF node. L is the grammar slot label used by the parser. pos is the position
within slot L.
*/
func GetNode(L int, w, z Node) Node {
	fmt.Printf("GetNode %s FiR=%t EoR=%t\n", slots[L].String, slots[L].FiR, slots[L].EoR)
	if slots[L].FiR {
		return z
	}
	var y Node
	var j int
	k := z.GetLeftExtent()
	i := z.GetRightExtent()
	if w == Dummy {
		j = z.GetLeftExtent()
	} else {
		j = w.GetLeftExtent()
	}
	if slots[L].EoR {
		y = getSymbolNode(slots[L].Head, j, i)
	} else {
		y = getIntermediateNode(L, j, i)
	}
	if !y.HasChild(L, k) {
		child := &PackedNode{
			PNKey: PNKey{
				SlotLabel:   L,
				RightExtent: k,
			},
			LeftChild:  w,
			RightChild: z,
		}
		// fmt.Printf(" %s.setChild %s\n", y.DotLabel(), child.DotLabel())
		y.SetChild(child)
		packedNodes[child.PNKey] = child
	}
	return y
}

func GetNodeE(i int) Node {
	return getSymbolNode(Empty, i, i)
}

func GetNodeT(symbol string, i, size int) *SymbolNode {
	fmt.Printf("GetNodeT(%s, %d, %d)\n", symbol, i, size)
	return getSymbolNode(symbol, i, i+size)
}

func getIntermediateNode(L, j, i int) *IntermediateNode {
	sn := &IntermediateNode{
		InKey: InKey{
			SlotLabel: L,
			Extent:    Extent{j, i},
		},
	}
	n, exist := intermediateNodes[sn.InKey]
	// fmt.Printf("getIntermediateNode %s exist=%t\n", sn.DotLabel(), exist)
	if !exist {
		intermediateNodes[sn.InKey] = sn
		return sn
	}
	return n
}

func getSymbolNode(symbol string, i, j int) *SymbolNode {
	sn := &SymbolNode{
		SNKey: SNKey{
			Symbol: symbol,
			Extent: Extent{i, j},
		},
	}
	if n, exist := symbolNodes[sn.SNKey]; !exist {
		symbolNodes[sn.SNKey] = sn
		return sn
	} else {
		return n
	}
}

/*** IntermediateNode ***/

type IntermediateNode struct {
	InKey
	Children []*PackedNode
}

type InKey struct {
	SlotLabel int
	Extent
}

func (sn *IntermediateNode) Equal(n Node) bool {
	n1, ok := n.(*IntermediateNode)
	if !ok {
		return false
	}
	return sn.SlotLabel == n1.SlotLabel && sn.Extent == n1.Extent
}

func (sn *IntermediateNode) DotLabel() string {
	return fmt.Sprintf("%s, %d, %d", slots[sn.SlotLabel].String, sn.Extent.Left, sn.Extent.Right)
}

func (sn *IntermediateNode) GetExtent() (left, right int) {
	return sn.Extent.Left, sn.Extent.Right
}

func (sn *IntermediateNode) GetLeftExtent() int {
	return sn.Extent.Left
}

func (sn *IntermediateNode) GetRightExtent() int {
	return sn.Extent.Right
}

func (sn *IntermediateNode) HasChild(L, k int) bool {
	for _, c := range sn.Children {
		if c.EqualPN(L, k) {
			return true
		}
	}
	return false
}

func (sn *IntermediateNode) SetChild(pn Node) {
	sn.Children = append(sn.Children, pn.(*PackedNode))
}

/*** PackedNode ***/

type PackedNode struct {
	PNKey
	LeftChild  Node
	RightChild Node
}

type PNKey struct {
	SlotLabel   int
	RightExtent int
}

func (sn *PackedNode) Equal(n Node) bool {
	n1, ok := n.(*PackedNode)
	if !ok {
		return false
	}
	return sn.SlotLabel == n1.SlotLabel && sn.RightExtent == n1.RightExtent
}

func (sn *PackedNode) DotLabel() string {
	return fmt.Sprintf("%s, %d", slots[sn.SlotLabel].String, sn.RightExtent)
}

func (sn *PackedNode) EqualPN(L, k int) bool {
	return sn.SlotLabel == L && sn.RightExtent == k
}

func (sn *PackedNode) GetExtent() (left, right int) {
	panic("not possible")
}

func (sn *PackedNode) GetLeftExtent() int {
	panic("not possible")
}

func (sn *PackedNode) GetRightExtent() int {
	return sn.RightExtent
}

func (sn *PackedNode) HasChild(L, k int) bool {
	panic("impossible")
}

func (sn *PackedNode) SetChild(pn Node) {
	panic("impossible")
}

/*** SymbolNode ***/

type SymbolNode struct {
	SNKey
	Children []*PackedNode
}

type SNKey struct {
	Symbol string
	Extent
}

func (sn *SymbolNode) Equal(n Node) bool {
	n1, ok := n.(*SymbolNode)
	if !ok {
		return false
	}
	return sn.Symbol == n1.Symbol && sn.Extent == n1.Extent
}

func (sn *SymbolNode) DotLabel() string {
	if sn == nil {
		return "dummy"
	}
	return fmt.Sprintf("%s, %d, %d", sn.Symbol, sn.Extent.Left, sn.Extent.Right)
}

func (sn *SymbolNode) GetExtent() (left, right int) {
	return sn.Extent.Left, sn.Extent.Right
}

func (sn *SymbolNode) GetLeftExtent() int {
	return sn.Extent.Left
}

func (sn *SymbolNode) GetRightExtent() int {
	return sn.Extent.Right
}

func (sn *SymbolNode) HasChild(L, k int) bool {
	for _, c := range sn.Children {
		if c.EqualPN(L, k) {
			return true
		}
	}
	return false
}

func (sn *SymbolNode) SetChild(pn Node) {
	sn.Children = append(sn.Children, pn.(*PackedNode))
}

`
