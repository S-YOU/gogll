package sppf

import (
	"bytes"
	"gogll/ast"
	"gogll/gslot"
	"io/ioutil"
	"os"
	"path/filepath"
	"text/template"
)

func Gen(parserDir string) {
	tmpl, err := template.New("sppf").Parse(src)
	if err != nil {
		panic(err)
	}
	buf := new(bytes.Buffer)
	if err := tmpl.Execute(buf, getData()); err != nil {
		panic(err)
	}
	sppfDir := filepath.Join(parserDir, "sppf")
	sppfFile := filepath.Join(sppfDir, "sppf.go")
	if err := os.MkdirAll(sppfDir, 0731); err != nil {
		panic(err)
	}
	if err := ioutil.WriteFile(sppfFile, buf.Bytes(), 0731); err != nil {
		panic(err)
	}
}

type Data struct {
	Package string
	Slots   []*Slot
}

type Slot struct {
	Label  string
	Head   string
	EoR    bool
	FiR    bool
	String string
}

func getData() *Data {
	data := &Data{
		Package: ast.GetPackage(),
		Slots:   getSlots(),
	}
	return data
}

func getSlots() (slots []*Slot) {
	for _, s := range gslot.GetSlots() {
		s1 := &Slot{
			Label:  s.Label(),
			Head:   s.Head,
			EoR:    s.IsEoR(),
			FiR:    s.IsFiR(),
			String: s.String(),
		}
		slots = append(slots, s1)
	}
	return
}

const src = `
/*
Packge sppf is generated by gogll. Do not edit.
Package sppf implements a binarised shared packed parse forest
*/
package sppf

import(
	"bytes"
	"fmt"
	
	"{{.Package}}/parser/labels"
)

// Empty denotes the empty string. It is represented by the character, 'ϵ'
const Empty = "ϵ"

var (
	intermediateNodes = make(map[InKey]*IntermediateNode)
	packedNodes       = make(map[PNKey]*PackedNode)
	symbolNodes       = make(map[SNKey]*SymbolNode)
	// Key=slot label
	slots = map[int]*GrammarSlot{ {{range $i, $s := .Slots}}
		labels.{{$s.Label}}: &GrammarSlot{
						Head: "{{$s.Head}}",
						EoR: {{$s.EoR}},
						FiR: {{$s.FiR}},
						String: "{{$s.String}}",
					  },{{end}}
	}
)

type GrammarSlot struct {
	Head string
	Body []string
	FiR bool
	EoR bool
	String string
}

type Node interface {
	Equal(Node) bool
	GetExtent() (left, right int)
	GetLeftExtent() int
	GetRightExtent() int
	HasChild(L int, k int) bool
	SetChild(Node)
}

type Extent struct {
	Left  int
	Right int
}

var Dummy Node = nil

type Edge struct {
	from, to Node
}

func ExistSymNode(sym string, left, right int) bool {
	snk := &SNKey{
		Symbol: sym,
		Extent: Extent{
			Left:  left,
			Right: right,
		},
	}
	_, exist := symbolNodes[*snk]
	return exist
}

/*
GetNode returns an SPPF node. L is the grammar slot label used by the parser. pos is the position
within slot L.
*/
func GetNode(L int, w, z Node) Node {
	if slots[L].FiR {
		return z
	}
	var y Node
	var j int
	k := z.GetLeftExtent()
	i := z.GetRightExtent()
	if w == Dummy {
		j = z.GetLeftExtent()
	} else {
		j = w.GetRightExtent()
	}
	if slots[L].EoR {
		y = getSymbolNode(slots[L].Head, j, i)
	} else {
		y = getIntermediateNode(L, j, i)
	}
	if !y.HasChild(L, k) {
		child := &PackedNode{
			PNKey: PNKey{
				SlotLabel:   L,
				RightExtent: k,
			},
			LeftChild:  w,
			RightChild: z,
		}
		y.SetChild(child)
		packedNodes[child.PNKey] = child
	}
	return y
}

func GetNodeE(i int) Node {
	return getSymbolNode(Empty, i, i)
}

func GetNodeT(symbol string, i, size int) *SymbolNode {
	return getSymbolNode(symbol, i, i+size)
}

func getIntermediateNode(L, j, i int) *IntermediateNode {
	sn := &IntermediateNode{
		InKey: InKey{
			SlotLabel: L,
			Extent:    Extent{j, i},
		},
	}
	if n, exist := intermediateNodes[sn.InKey]; !exist {
		intermediateNodes[sn.InKey] = sn
		return sn
	} else {
		return n
	}
}

func getSymbolNode(symbol string, i, j int) *SymbolNode {
	sn := &SymbolNode{
		SNKey: SNKey{
			Symbol: symbol,
			Extent: Extent{i, j},
		},
	}
	if n, exist := symbolNodes[sn.SNKey]; !exist {
		symbolNodes[sn.SNKey] = sn
		return sn
	} else {
		return n
	}
}

/*** IntermediateNode ***/

type IntermediateNode struct {
	InKey
	Child *PackedNode
}

type InKey struct {
	SlotLabel int
	Extent
}

func (sn *IntermediateNode) Equal(n Node) bool {
	n1, ok := n.(*IntermediateNode)
	if !ok {
		return false
	}
	return sn.SlotLabel == n1.SlotLabel && sn.Extent == n1.Extent
}

func (sn *IntermediateNode) GetExtent() (left, right int) {
	return sn.Extent.Left, sn.Extent.Right
}

func (sn *IntermediateNode) GetLeftExtent() int {
	return sn.Extent.Left
}

func (sn *IntermediateNode) GetRightExtent() int {
	return sn.Extent.Right
}

func (sn *IntermediateNode) HasChild(L, k int) bool {
	if sn.Child == nil {
		return false
	}
	return sn.Child.EqualPN(L, k)
}

func (sn *IntermediateNode) SetChild(pn Node) {
	sn.Child = pn.(*PackedNode)
}

/*** PackedNode ***/

type PackedNode struct {
	PNKey
	LeftChild  Node
	RightChild Node
}

type PNKey struct {
	SlotLabel   int
	RightExtent int
}

func (sn *PackedNode) Equal(n Node) bool {
	n1, ok := n.(*PackedNode)
	if !ok {
		return false
	}
	return sn.SlotLabel == n1.SlotLabel && sn.RightExtent == n1.RightExtent
}

func (sn *PackedNode) EqualPN(L, k int) bool {
	return sn.SlotLabel == L && sn.RightExtent == k
}

func (sn *PackedNode) GetExtent() (left, right int) {
	panic("not possible")
}

func (sn *PackedNode) GetLeftExtent() int {
	panic("not possible")
}

func (sn *PackedNode) GetRightExtent() int {
	return sn.RightExtent
}

func (sn *PackedNode) HasChild(L, k int) bool {
	panic("impossible")
}

func (sn *PackedNode) SetChild(pn Node) {
	panic("impossible")
}

/*** SymbolNode ***/

type SymbolNode struct {
	SNKey
	Child *PackedNode
}

type SNKey struct {
	Symbol string
	Extent
}

func (sn *SymbolNode) Equal(n Node) bool {
	n1, ok := n.(*SymbolNode)
	if !ok {
		return false
	}
	return sn.Symbol == n1.Symbol && sn.Extent == n1.Extent
}

func (sn *SymbolNode) GetExtent() (left, right int) {
	return sn.Extent.Left, sn.Extent.Right
}

func (sn *SymbolNode) GetLeftExtent() int {
	return sn.Extent.Left
}

func (sn *SymbolNode) GetRightExtent() int {
	return sn.Extent.Right
}

func (sn *SymbolNode) HasChild(L, k int) bool {
	if sn.Child == nil {
		return false
	}
	return sn.Child.EqualPN(L, k)
}

func (sn *SymbolNode) SetChild(pn Node) {
	sn.Child = pn.(*PackedNode)
}

/*** Dot output ***/

func Dot() string {
	buf := new(bytes.Buffer)
	buf.WriteString("digraph sppf{\n")
	buf.WriteString(DotNodes())
	buf.WriteString("}\n")
	return buf.String()
}

func DotNodes() string {
	buf := new(bytes.Buffer)
	buf.WriteString(DotSymbolNodes())
	buf.WriteString(DotIntermediateNodes())
	buf.WriteString(DotPackedNodes())
	return buf.String()
}

func DotSymbolNodes() string {
	buf := new(bytes.Buffer)
	// for {

	// }
	return buf.String()
}

func DotIntermediateNodes() string {
	buf := new(bytes.Buffer)
	for _, n := range symbolNodes {
		buf.WriteString(n.String())
	}
	return buf.String()
}

func DotPackedNodes() string {
	buf := new(bytes.Buffer)
	// for {

	// }
	return buf.String()
}

func (s *SymbolNode) String() string {
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "%s\n", s.Symbol)
	return buf.String()
}

`
